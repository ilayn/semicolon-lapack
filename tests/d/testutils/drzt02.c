/**
 * @file drzt02.c
 * @brief DRZT02 returns || I - Q'*Q || / (M * eps) for DTZRZF.
 *
 * Port of LAPACK TESTING/LIN/drzt02.f to C.
 */

#include <math.h>
#include "verify.h"

/* External declarations */
extern f64 dlamch(const char* cmach);
extern f64 dlange(const char* norm, const int m, const int n,
                     const f64* A, const int lda, f64* work);
extern void dlaset(const char* uplo, const int m, const int n,
                   const f64 alpha, const f64 beta,
                   f64* A, const int lda);
extern void dormrz(const char* side, const char* trans,
                   const int m, const int n, const int k, const int l,
                   const f64* A, const int lda, const f64* tau,
                   f64* C, const int ldc, f64* work, const int lwork,
                   int* info);

/**
 * DRZT02 returns
 *    || I - Q'*Q || / (M * eps)
 * where the matrix Q is defined by the Householder transformations
 * generated by DTZRZF.
 *
 * @param[in]  m     The number of rows of the matrix AF.
 * @param[in]  n     The number of columns of the matrix AF.
 * @param[in]  AF    Array (lda, n). The output of DTZRZF.
 * @param[in]  lda   The leading dimension of the array AF.
 * @param[in]  tau   Array (m). Details of the Householder transformations.
 * @param[out] work  Array (lwork). Workspace.
 * @param[in]  lwork The length of the array work. lwork >= n*n + n.
 *
 * @return || I - Q'*Q || / (M * eps).
 */
f64 drzt02(const int m, const int n, const f64* AF, const int lda,
              const f64* tau, f64* work, const int lwork)
{
    const f64 ZERO = 0.0;
    const f64 ONE = 1.0;
    int i, info;
    f64 rwork[1];

    /* Quick return if possible */
    if (m <= 0 || n <= 0) {
        return ZERO;
    }

    /* Test for sufficient workspace */
    if (lwork < n * n + n) {
        return ZERO;
    }

    /* Q := I */
    dlaset("F", n, n, ZERO, ONE, work, n);

    /* Q := P(0) * ... * P(m-1) * Q
     * Using dormrz with side='L' and trans='N'. */
    dormrz("L", "N", n, n, m, n - m, AF, lda, tau,
           work, n, &work[n * n], lwork - n * n, &info);

    /* Q := P(m-1) * ... * P(0) * Q = Q' * Q
     * Using dormrz with side='L' and trans='T'. */
    dormrz("L", "T", n, n, m, n - m, AF, lda, tau,
           work, n, &work[n * n], lwork - n * n, &info);

    /* Q := Q - I */
    for (i = 0; i < n; i++) {
        work[i * n + i] -= ONE;
    }

    /* Compute ||Q - I|| / (eps * max(M,N)) */
    return dlange("1", n, n, work, n, rwork) /
           (dlamch("E") * (f64)((m > n) ? m : n));
}
