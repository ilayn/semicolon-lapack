/**
 * @file srzt02.c
 * @brief SRZT02 returns || I - Q'*Q || / (M * eps) for STZRZF.
 *
 * Port of LAPACK TESTING/LIN/srzt02.f to C.
 */

#include <math.h>
#include "verify.h"

/* External declarations */
extern f32 slamch(const char* cmach);
extern f32 slange(const char* norm, const int m, const int n,
                     const f32* A, const int lda, f32* work);
extern void slaset(const char* uplo, const int m, const int n,
                   const f32 alpha, const f32 beta,
                   f32* A, const int lda);
extern void sormrz(const char* side, const char* trans,
                   const int m, const int n, const int k, const int l,
                   const f32* A, const int lda, const f32* tau,
                   f32* C, const int ldc, f32* work, const int lwork,
                   int* info);

/**
 * SRZT02 returns
 *    || I - Q'*Q || / (M * eps)
 * where the matrix Q is defined by the Householder transformations
 * generated by STZRZF.
 *
 * @param[in]  m     The number of rows of the matrix AF.
 * @param[in]  n     The number of columns of the matrix AF.
 * @param[in]  AF    Array (lda, n). The output of STZRZF.
 * @param[in]  lda   The leading dimension of the array AF.
 * @param[in]  tau   Array (m). Details of the Householder transformations.
 * @param[out] work  Array (lwork). Workspace.
 * @param[in]  lwork The length of the array work. lwork >= n*n + n.
 *
 * @return || I - Q'*Q || / (M * eps).
 */
f32 srzt02(const int m, const int n, const f32* AF, const int lda,
              const f32* tau, f32* work, const int lwork)
{
    const f32 ZERO = 0.0f;
    const f32 ONE = 1.0f;
    int i, info;
    f32 rwork[1];

    /* Quick return if possible */
    if (m <= 0 || n <= 0) {
        return ZERO;
    }

    /* Test for sufficient workspace */
    if (lwork < n * n + n) {
        return ZERO;
    }

    /* Q := I */
    slaset("F", n, n, ZERO, ONE, work, n);

    /* Q := P(0) * ... * P(m-1) * Q
     * Using sormrz with side='L' and trans='N'. */
    sormrz("L", "N", n, n, m, n - m, AF, lda, tau,
           work, n, &work[n * n], lwork - n * n, &info);

    /* Q := P(m-1) * ... * P(0) * Q = Q' * Q
     * Using sormrz with side='L' and trans='T'. */
    sormrz("L", "T", n, n, m, n - m, AF, lda, tau,
           work, n, &work[n * n], lwork - n * n, &info);

    /* Q := Q - I */
    for (i = 0; i < n; i++) {
        work[i * n + i] -= ONE;
    }

    /* Compute ||Q - I|| / (eps * max(M,N)) */
    return slange("1", n, n, work, n, rwork) /
           (slamch("E") * (f32)((m > n) ? m : n));
}
