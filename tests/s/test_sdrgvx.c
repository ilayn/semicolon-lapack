/**
 * @file test_sdrgvx.c
 * @brief Generalized nonsymmetric eigenvalue expert driver test - port of
 *        LAPACK TESTING/EIG/ddrgvx.f
 *
 * Tests the nonsymmetric generalized eigenvalue problem expert driver SGGEVX.
 *
 * SGGEVX computes the generalized eigenvalues, (optionally) the left
 * and/or right eigenvectors, (optionally) computes a balancing
 * transformation to improve the conditioning, and (optionally)
 * reciprocal condition numbers for the eigenvalues and eigenvectors.
 *
 * Two types of 5x5 test matrix pairs are generated by SLATM6 and
 * tested with SGGEVX. The test matrices have known exact condition
 * numbers for eigenvalues. For the condition numbers of the eigenvectors
 * corresponding to the first and last eigenvalues are also known
 * "exactly" (see SLATM6).
 *
 * Test ratios (4 total):
 *   (1) max | l^H (beta A - alpha B) | / ( ulp max(|beta A|, |alpha B|) )
 *   (2) max | (beta A - alpha B) r | / ( ulp max(|beta A|, |alpha B|) )
 *   (3) max( |S_est/S_true|, |S_true/S_est| ) over all eigenvalues
 *   (4) max( |DIF_est/DIF_true|, |DIF_true/DIF_est| ) over 1st and 5th eigenvectors
 *
 * Matrix types (2 total):
 *   Type 1: Da diagonal, Db identity
 *   Type 2: Da quasi-diagonal with 2x2 complex block, Db identity
 *
 * Weight parameters: {0.1, 0.5, 1.0, 2.0, 10.0}
 * Each (iptype, iwa, iwb, iwx, iwy) is a separate test case.
 * Total: 2 x 5^4 = 1250 test cases.
 */

#include "test_harness.h"
#include "verify.h"
#include <cblas.h>
#include <math.h>
#include <string.h>

#define THRESH 10.0f
#define NMAX 5

static const f32 WEIGHT[5] = {0.1f, 0.5f, 1.0f, 2.0f, 10.0f};

extern void sggevx(const char* balanc, const char* jobvl, const char* jobvr,
                   const char* sense, const int n, f32* A, const int lda,
                   f32* B, const int ldb, f32* alphar, f32* alphai,
                   f32* beta, f32* VL, const int ldvl, f32* VR,
                   const int ldvr, int* ilo, int* ihi,
                   f32* lscale, f32* rscale,
                   f32* abnrm, f32* bbnrm,
                   f32* rconde, f32* rcondv,
                   f32* work, const int lwork, int* iwork,
                   int* bwork, int* info);
extern f32 slamch(const char* cmach);
extern f32 slange(const char* norm, const int m, const int n,
                  const f32* A, const int lda, f32* work);
extern void slacpy(const char* uplo, const int m, const int n,
                   const f32* A, const int lda, f32* B, const int ldb);

typedef struct {
    int iptype;
    int iwa, iwb, iwx, iwy;
    char name[96];
} ddrgvx_params_t;

typedef struct {
    f32* A;
    f32* B;
    f32* AI;
    f32* BI;
    f32* VL;
    f32* VR;
    f32* alphar;
    f32* alphai;
    f32* beta;
    f32* lscale;
    f32* rscale;
    f32* S;
    f32* dtru;
    f32* DIF;
    f32* diftru;
    f32* work;
    int* iwork;
    int* bwork;
    int lwork;
} ddrgvx_workspace_t;

static ddrgvx_workspace_t* g_ws = NULL;

static int group_setup(void** state)
{
    (void)state;

    g_ws = calloc(1, sizeof(ddrgvx_workspace_t));
    if (!g_ws) return -1;

    const int n = NMAX;
    const int n2 = n * n;

    g_ws->A      = malloc(n2 * sizeof(f32));
    g_ws->B      = malloc(n2 * sizeof(f32));
    g_ws->AI     = malloc(n2 * sizeof(f32));
    g_ws->BI     = malloc(n2 * sizeof(f32));
    g_ws->VL     = malloc(n2 * sizeof(f32));
    g_ws->VR     = malloc(n2 * sizeof(f32));
    g_ws->alphar = malloc(n * sizeof(f32));
    g_ws->alphai = malloc(n * sizeof(f32));
    g_ws->beta   = malloc(n * sizeof(f32));
    g_ws->lscale = malloc(n * sizeof(f32));
    g_ws->rscale = malloc(n * sizeof(f32));
    g_ws->S      = malloc(n * sizeof(f32));
    g_ws->dtru   = malloc(n * sizeof(f32));
    g_ws->DIF    = malloc(n * sizeof(f32));
    g_ws->diftru = malloc(n * sizeof(f32));

    g_ws->lwork = 2 * n * n + 12 * n + 16;
    g_ws->work  = malloc(g_ws->lwork * sizeof(f32));
    g_ws->iwork = malloc((n + 6) * sizeof(int));
    g_ws->bwork = malloc(n * sizeof(int));

    if (!g_ws->A || !g_ws->B || !g_ws->AI || !g_ws->BI ||
        !g_ws->VL || !g_ws->VR || !g_ws->alphar || !g_ws->alphai ||
        !g_ws->beta || !g_ws->lscale || !g_ws->rscale ||
        !g_ws->S || !g_ws->dtru || !g_ws->DIF || !g_ws->diftru ||
        !g_ws->work || !g_ws->iwork || !g_ws->bwork) {
        return -1;
    }

    return 0;
}

static int group_teardown(void** state)
{
    (void)state;

    if (g_ws) {
        free(g_ws->A);
        free(g_ws->B);
        free(g_ws->AI);
        free(g_ws->BI);
        free(g_ws->VL);
        free(g_ws->VR);
        free(g_ws->alphar);
        free(g_ws->alphai);
        free(g_ws->beta);
        free(g_ws->lscale);
        free(g_ws->rscale);
        free(g_ws->S);
        free(g_ws->dtru);
        free(g_ws->DIF);
        free(g_ws->diftru);
        free(g_ws->work);
        free(g_ws->iwork);
        free(g_ws->bwork);
        free(g_ws);
        g_ws = NULL;
    }
    return 0;
}

static void test_ddrgvx(void** state)
{
    (void)state;
    ddrgvx_params_t* params = (ddrgvx_params_t*)(*state);

    const int n = NMAX;
    const int lda = NMAX;
    const f32 ulp = slamch("P");
    const f32 ulpinv = 1.0f / ulp;
    const f32 thrsh2 = 10.0f * THRESH;

    f32 result[4] = {0.0f, 0.0f, 0.0f, 0.0f};

    slatm6(params->iptype, 5, g_ws->A, lda, g_ws->B,
           g_ws->VR, lda, g_ws->VL, lda,
           WEIGHT[params->iwa], WEIGHT[params->iwb],
           WEIGHT[params->iwx], WEIGHT[params->iwy],
           g_ws->dtru, g_ws->diftru);

    slacpy("F", n, n, g_ws->A, lda, g_ws->AI, lda);
    slacpy("F", n, n, g_ws->B, lda, g_ws->BI, lda);

    int ilo, ihi, linfo;
    f32 anorm, bnorm;
    sggevx("N", "V", "V", "B", n, g_ws->AI, lda, g_ws->BI, lda,
           g_ws->alphar, g_ws->alphai, g_ws->beta, g_ws->VL, lda,
           g_ws->VR, lda, &ilo, &ihi, g_ws->lscale, g_ws->rscale,
           &anorm, &bnorm, g_ws->S, g_ws->DIF, g_ws->work, g_ws->lwork,
           g_ws->iwork, g_ws->bwork, &linfo);

    if (linfo != 0) {
        print_message("SGGEVX returned INFO=%d for type=%d iwa=%d iwb=%d iwx=%d iwy=%d\n",
                      linfo, params->iptype, params->iwa + 1,
                      params->iwb + 1, params->iwx + 1, params->iwy + 1);
        result[0] = ulpinv;
        assert_residual_ok(result[0]);
        return;
    }

    /* Compute norm(A, B) */
    slacpy("Full", n, n, g_ws->AI, lda, g_ws->work, n);
    slacpy("Full", n, n, g_ws->BI, lda, &g_ws->work[n * n], n);
    f32 abnorm = slange("Fro", n, 2 * n, g_ws->work, n, g_ws->work);

    /* Test (1): Left eigenvector residual via sget52 */
    f32 res52[2];
    result[0] = 0.0f;
    sget52(1, n, g_ws->A, lda, g_ws->B, lda, g_ws->VL, lda,
           g_ws->alphar, g_ws->alphai, g_ws->beta, g_ws->work, res52);
    result[0] = res52[0];
    if (res52[1] > THRESH) {
        print_message("Left eigenvectors from SGGEVX incorrectly normalized: %.3g\n",
                      (double)res52[1]);
    }

    /* Test (2): Right eigenvector residual via sget52 */
    result[1] = 0.0f;
    sget52(0, n, g_ws->A, lda, g_ws->B, lda, g_ws->VR, lda,
           g_ws->alphar, g_ws->alphai, g_ws->beta, g_ws->work, res52);
    result[1] = res52[0];
    if (res52[1] > THRESH) {
        print_message("Right eigenvectors from SGGEVX incorrectly normalized: %.3g\n",
                      (double)res52[1]);
    }

    /* Test (3): Eigenvalue condition numbers */
    result[2] = 0.0f;
    for (int i = 0; i < n; i++) {
        if (g_ws->S[i] == 0.0f) {
            if (g_ws->dtru[i] > abnorm * ulp)
                result[2] = ulpinv;
        } else if (g_ws->dtru[i] == 0.0f) {
            if (g_ws->S[i] > abnorm * ulp)
                result[2] = ulpinv;
        } else {
            f32 ratio = fmaxf(fabsf(g_ws->dtru[i] / g_ws->S[i]),
                             fabsf(g_ws->S[i] / g_ws->dtru[i]));
            result[2] = fmaxf(result[2], ratio);
        }
    }

    /* Test (4): Eigenvector condition numbers (1st and 5th) */
    result[3] = 0.0f;
    if (g_ws->DIF[0] == 0.0f) {
        if (g_ws->diftru[0] > abnorm * ulp)
            result[3] = ulpinv;
    } else if (g_ws->diftru[0] == 0.0f) {
        if (g_ws->DIF[0] > abnorm * ulp)
            result[3] = ulpinv;
    } else if (g_ws->DIF[4] == 0.0f) {
        if (g_ws->diftru[4] > abnorm * ulp)
            result[3] = ulpinv;
    } else if (g_ws->diftru[4] == 0.0f) {
        if (g_ws->DIF[4] > abnorm * ulp)
            result[3] = ulpinv;
    } else {
        f32 ratio1 = fmaxf(fabsf(g_ws->diftru[0] / g_ws->DIF[0]),
                          fabsf(g_ws->DIF[0] / g_ws->diftru[0]));
        f32 ratio2 = fmaxf(fabsf(g_ws->diftru[4] / g_ws->DIF[4]),
                          fabsf(g_ws->DIF[4] / g_ws->diftru[4]));
        result[3] = fmaxf(ratio1, ratio2);
    }

    /* Check results against thresholds */
    int any_fail = 0;
    for (int j = 0; j < 4; j++) {
        f32 thr = (j >= 3) ? thrsh2 : THRESH;
        if (result[j] >= thr) {
            print_message("type=%d iwa=%d iwb=%d iwx=%d iwy=%d test(%d)=%g >= %.1f\n",
                          params->iptype, params->iwa + 1, params->iwb + 1,
                          params->iwx + 1, params->iwy + 1, j + 1, (double)result[j], (double)thr);
            any_fail = 1;
        }
    }
    assert_int_equal(any_fail, 0);
}

/*
 * Section 2: Read-in test data from dgd.in (LAPACK TESTING/dgd.in lines 64-86).
 * Two precomputed 4x4 matrix pairs with known eigenvalue/eigenvector condition
 * numbers, used to check accuracy of condition estimation in SGGEVX.
 */

#define NREADIN 2
#define NREADIN_DIM 4

typedef struct {
    int n;
    int idx;
    char name[64];
} ddrgvx_readin_params_t;

/* Column-major storage */
static const f32 readin_A[NREADIN][16] = {
    /* Case 1: upper triangular */
    {  8.0f,  0.0f,  0.0f,  0.0f,
       4.0f,  7.0f,  0.0f,  0.0f,
     -13.0f,-24.0f,  3.0f,  0.0f,
       4.0f, -3.0f, -5.0f, 16.0f },
    /* Case 2: upper triangular */
    {  1.0f,  0.0f,  0.0f,  0.0f,
       2.0f,  5.0f,  0.0f,  0.0f,
       3.0f,  6.0f,  8.0f,  0.0f,
       4.0f,  7.0f,  9.0f, 10.0f }
};

static const f32 readin_B[NREADIN][16] = {
    {  9.0f,  0.0f,  0.0f,  0.0f,
      -1.0f,  4.0f,  0.0f,  0.0f,
       1.0f, 16.0f,-11.0f,  0.0f,
      -6.0f,-24.0f,  6.0f,  4.0f },
    { -1.0f,  0.0f,  0.0f,  0.0f,
      -1.0f, -1.0f,  0.0f,  0.0f,
      -1.0f, -1.0f,  1.0f,  0.0f,
      -1.0f, -1.0f, -1.0f,  1.0f }
};

static const f32 readin_dtru[NREADIN][4] = {
    { 3.1476e+00f, 2.5286e+00f, 4.2241e+00f, 3.4160e+00f },
    { 1.3639e+00f, 4.0417e+00f, 6.4089e-01f, 6.8030e-01f }
};

static const f32 readin_diftru[NREADIN][4] = {
    { 6.7340e-01f, 1.1380e+00f, 3.5424e+00f, 9.5917e-01f },
    { 7.6064e-01f, 8.4964e-01f, 1.1222e-01f, 1.1499e-01f }
};

static void test_ddrgvx_readin(void** state)
{
    (void)state;
    ddrgvx_readin_params_t* params = (ddrgvx_readin_params_t*)(*state);

    const int n = params->n;
    const int lda = NMAX;
    const int ci = params->idx;
    const f32 ulp = slamch("P");
    const f32 ulpinv = 1.0f / ulp;
    const f32 thrsh2 = 10.0f * THRESH;

    f32 result[4] = {0.0f, 0.0f, 0.0f, 0.0f};

    /* Load precomputed matrices into workspace (lda may differ from n) */
    for (int j = 0; j < n; j++)
        for (int i = 0; i < n; i++) {
            g_ws->A[i + j * lda] = readin_A[ci][i + j * n];
            g_ws->B[i + j * lda] = readin_B[ci][i + j * n];
        }

    slacpy("F", n, n, g_ws->A, lda, g_ws->AI, lda);
    slacpy("F", n, n, g_ws->B, lda, g_ws->BI, lda);

    int ilo, ihi, linfo;
    f32 anorm, bnorm;
    sggevx("N", "V", "V", "B", n, g_ws->AI, lda, g_ws->BI, lda,
           g_ws->alphar, g_ws->alphai, g_ws->beta, g_ws->VL, lda,
           g_ws->VR, lda, &ilo, &ihi, g_ws->lscale, g_ws->rscale,
           &anorm, &bnorm, g_ws->S, g_ws->DIF, g_ws->work, g_ws->lwork,
           g_ws->iwork, g_ws->bwork, &linfo);

    if (linfo != 0) {
        print_message("SGGEVX returned INFO=%d for read-in example #%d\n",
                      linfo, ci + 1);
        result[0] = ulpinv;
        assert_residual_below(result[0], thrsh2);
        return;
    }

    /* Compute norm(A, B) */
    slacpy("Full", n, n, g_ws->AI, lda, g_ws->work, n);
    slacpy("Full", n, n, g_ws->BI, lda, &g_ws->work[n * n], n);
    f32 abnorm = slange("Fro", n, 2 * n, g_ws->work, n, g_ws->work);

    /* Test (1): Left eigenvector residual */
    f32 res52[2];
    result[0] = 0.0f;
    sget52(1, n, g_ws->A, lda, g_ws->B, lda, g_ws->VL, lda,
           g_ws->alphar, g_ws->alphai, g_ws->beta, g_ws->work, res52);
    result[0] = res52[0];
    if (res52[1] > THRESH) {
        print_message("Left eigenvectors from SGGEVX incorrectly normalized: "
                      "%.3g (read-in #%d)\n", (double)res52[1], ci + 1);
    }

    /* Test (2): Right eigenvector residual */
    result[1] = 0.0f;
    sget52(0, n, g_ws->A, lda, g_ws->B, lda, g_ws->VR, lda,
           g_ws->alphar, g_ws->alphai, g_ws->beta, g_ws->work, res52);
    result[1] = res52[0];
    if (res52[1] > THRESH) {
        print_message("Right eigenvectors from SGGEVX incorrectly normalized: "
                      "%.3g (read-in #%d)\n", (double)res52[1], ci + 1);
    }

    /* Test (3): Eigenvalue condition numbers */
    result[2] = 0.0f;
    for (int i = 0; i < n; i++) {
        if (g_ws->S[i] == 0.0f) {
            if (readin_dtru[ci][i] > abnorm * ulp)
                result[2] = ulpinv;
        } else if (readin_dtru[ci][i] == 0.0f) {
            if (g_ws->S[i] > abnorm * ulp)
                result[2] = ulpinv;
        } else {
            f32 ratio = fmaxf(fabsf(readin_dtru[ci][i] / g_ws->S[i]),
                             fabsf(g_ws->S[i] / readin_dtru[ci][i]));
            result[2] = fmaxf(result[2], ratio);
        }
    }

    /* Test (4): Eigenvector condition numbers (1st and last) */
    result[3] = 0.0f;
    if (g_ws->DIF[0] == 0.0f) {
        if (readin_diftru[ci][0] > abnorm * ulp)
            result[3] = ulpinv;
    } else if (readin_diftru[ci][0] == 0.0f) {
        if (g_ws->DIF[0] > abnorm * ulp)
            result[3] = ulpinv;
    } else if (g_ws->DIF[n - 1] == 0.0f) {
        if (readin_diftru[ci][n - 1] > abnorm * ulp)
            result[3] = ulpinv;
    } else if (readin_diftru[ci][n - 1] == 0.0f) {
        if (g_ws->DIF[n - 1] > abnorm * ulp)
            result[3] = ulpinv;
    } else {
        f32 ratio1 = fmaxf(fabsf(readin_diftru[ci][0] / g_ws->DIF[0]),
                          fabsf(g_ws->DIF[0] / readin_diftru[ci][0]));
        f32 ratio2 = fmaxf(fabsf(readin_diftru[ci][n - 1] / g_ws->DIF[n - 1]),
                          fabsf(g_ws->DIF[n - 1] / readin_diftru[ci][n - 1]));
        result[3] = fmaxf(ratio1, ratio2);
    }

    /* Check all 4 results against thrsh2 (read-in uses looser threshold) */
    int any_fail = 0;
    for (int j = 0; j < 4; j++) {
        if (result[j] >= thrsh2) {
            print_message("read-in #%d test(%d)=%g >= %.1f\n",
                          ci + 1, j + 1, (double)result[j], (double)thrsh2);
            any_fail = 1;
        }
    }
    assert_int_equal(any_fail, 0);
}

int main(void)
{
    /* 1250 built-in + 2 read-in = 1252 total */
    static ddrgvx_params_t all_params[2 * 5 * 5 * 5 * 5];
    static ddrgvx_readin_params_t readin_params[NREADIN];
    static struct CMUnitTest all_tests[2 * 5 * 5 * 5 * 5 + NREADIN];
    int idx = 0;

    /* Section 1: Built-in 5x5 tests via slatm6 (1250 cases) */
    for (int iptype = 1; iptype <= 2; iptype++) {
        for (int iwa = 0; iwa < 5; iwa++) {
            for (int iwb = 0; iwb < 5; iwb++) {
                for (int iwx = 0; iwx < 5; iwx++) {
                    for (int iwy = 0; iwy < 5; iwy++) {
                        ddrgvx_params_t* p = &all_params[idx];
                        p->iptype = iptype;
                        p->iwa = iwa;
                        p->iwb = iwb;
                        p->iwx = iwx;
                        p->iwy = iwy;
                        snprintf(p->name, sizeof(p->name),
                                 "type=%d_wa=%d_wb=%d_wx=%d_wy=%d",
                                 iptype, iwa + 1, iwb + 1, iwx + 1, iwy + 1);

                        all_tests[idx].name = p->name;
                        all_tests[idx].test_func = test_ddrgvx;
                        all_tests[idx].setup_func = NULL;
                        all_tests[idx].teardown_func = NULL;
                        all_tests[idx].initial_state = p;
                        idx++;
                    }
                }
            }
        }
    }

    /* Section 2: Read-in precomputed test matrices (2 cases from dgd.in) */
    for (int ci = 0; ci < NREADIN; ci++) {
        ddrgvx_readin_params_t* rp = &readin_params[ci];
        rp->n = NREADIN_DIM;
        rp->idx = ci;
        snprintf(rp->name, sizeof(rp->name), "readin_%d", ci + 1);

        all_tests[idx].name = rp->name;
        all_tests[idx].test_func = test_ddrgvx_readin;
        all_tests[idx].setup_func = NULL;
        all_tests[idx].teardown_func = NULL;
        all_tests[idx].initial_state = rp;
        idx++;
    }

    return cmocka_run_group_tests_name("ddrgvx", all_tests, group_setup,
                                       group_teardown);
}
