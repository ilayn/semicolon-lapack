/**
 * @file test_ddrgvx.c
 * @brief Generalized nonsymmetric eigenvalue expert driver test - port of
 *        LAPACK TESTING/EIG/ddrgvx.f
 *
 * Tests the nonsymmetric generalized eigenvalue problem expert driver DGGEVX.
 *
 * DGGEVX computes the generalized eigenvalues, (optionally) the left
 * and/or right eigenvectors, (optionally) computes a balancing
 * transformation to improve the conditioning, and (optionally)
 * reciprocal condition numbers for the eigenvalues and eigenvectors.
 *
 * Two types of 5x5 test matrix pairs are generated by DLATM6 and
 * tested with DGGEVX. The test matrices have known exact condition
 * numbers for eigenvalues. For the condition numbers of the eigenvectors
 * corresponding to the first and last eigenvalues are also known
 * "exactly" (see DLATM6).
 *
 * Test ratios (4 total):
 *   (1) max | l^H (beta A - alpha B) | / ( ulp max(|beta A|, |alpha B|) )
 *   (2) max | (beta A - alpha B) r | / ( ulp max(|beta A|, |alpha B|) )
 *   (3) max( |S_est/S_true|, |S_true/S_est| ) over all eigenvalues
 *   (4) max( |DIF_est/DIF_true|, |DIF_true/DIF_est| ) over 1st and 5th eigenvectors
 *
 * Matrix types (2 total):
 *   Type 1: Da diagonal, Db identity
 *   Type 2: Da quasi-diagonal with 2x2 complex block, Db identity
 *
 * Weight parameters: {0.1, 0.5, 1.0, 2.0, 10.0}
 * Each (iptype, iwa, iwb, iwx, iwy) is a separate test case.
 * Total: 2 x 5^4 = 1250 test cases.
 */

#include "test_harness.h"
#include "testutils/verify.h"
#include <cblas.h>
#include <math.h>
#include <string.h>

#define THRESH 10.0
#define NMAX 5

static const f64 WEIGHT[5] = {0.1, 0.5, 1.0, 2.0, 10.0};

extern void dggevx(const char* balanc, const char* jobvl, const char* jobvr,
                   const char* sense, const int n, f64* A, const int lda,
                   f64* B, const int ldb, f64* alphar, f64* alphai,
                   f64* beta, f64* VL, const int ldvl, f64* VR,
                   const int ldvr, int* ilo, int* ihi,
                   f64* lscale, f64* rscale,
                   f64* abnrm, f64* bbnrm,
                   f64* rconde, f64* rcondv,
                   f64* work, const int lwork, int* iwork,
                   int* bwork, int* info);
extern f64 dlamch(const char* cmach);
extern f64 dlange(const char* norm, const int m, const int n,
                  const f64* A, const int lda, f64* work);
extern void dlacpy(const char* uplo, const int m, const int n,
                   const f64* A, const int lda, f64* B, const int ldb);

typedef struct {
    int iptype;
    int iwa, iwb, iwx, iwy;
    char name[96];
} ddrgvx_params_t;

typedef struct {
    f64* A;
    f64* B;
    f64* AI;
    f64* BI;
    f64* VL;
    f64* VR;
    f64* alphar;
    f64* alphai;
    f64* beta;
    f64* lscale;
    f64* rscale;
    f64* S;
    f64* dtru;
    f64* DIF;
    f64* diftru;
    f64* work;
    int* iwork;
    int* bwork;
    int lwork;
} ddrgvx_workspace_t;

static ddrgvx_workspace_t* g_ws = NULL;

static int group_setup(void** state)
{
    (void)state;

    g_ws = calloc(1, sizeof(ddrgvx_workspace_t));
    if (!g_ws) return -1;

    const int n = NMAX;
    const int n2 = n * n;

    g_ws->A      = malloc(n2 * sizeof(f64));
    g_ws->B      = malloc(n2 * sizeof(f64));
    g_ws->AI     = malloc(n2 * sizeof(f64));
    g_ws->BI     = malloc(n2 * sizeof(f64));
    g_ws->VL     = malloc(n2 * sizeof(f64));
    g_ws->VR     = malloc(n2 * sizeof(f64));
    g_ws->alphar = malloc(n * sizeof(f64));
    g_ws->alphai = malloc(n * sizeof(f64));
    g_ws->beta   = malloc(n * sizeof(f64));
    g_ws->lscale = malloc(n * sizeof(f64));
    g_ws->rscale = malloc(n * sizeof(f64));
    g_ws->S      = malloc(n * sizeof(f64));
    g_ws->dtru   = malloc(n * sizeof(f64));
    g_ws->DIF    = malloc(n * sizeof(f64));
    g_ws->diftru = malloc(n * sizeof(f64));

    g_ws->lwork = 2 * n * n + 12 * n + 16;
    g_ws->work  = malloc(g_ws->lwork * sizeof(f64));
    g_ws->iwork = malloc((n + 6) * sizeof(int));
    g_ws->bwork = malloc(n * sizeof(int));

    if (!g_ws->A || !g_ws->B || !g_ws->AI || !g_ws->BI ||
        !g_ws->VL || !g_ws->VR || !g_ws->alphar || !g_ws->alphai ||
        !g_ws->beta || !g_ws->lscale || !g_ws->rscale ||
        !g_ws->S || !g_ws->dtru || !g_ws->DIF || !g_ws->diftru ||
        !g_ws->work || !g_ws->iwork || !g_ws->bwork) {
        return -1;
    }

    return 0;
}

static int group_teardown(void** state)
{
    (void)state;

    if (g_ws) {
        free(g_ws->A);
        free(g_ws->B);
        free(g_ws->AI);
        free(g_ws->BI);
        free(g_ws->VL);
        free(g_ws->VR);
        free(g_ws->alphar);
        free(g_ws->alphai);
        free(g_ws->beta);
        free(g_ws->lscale);
        free(g_ws->rscale);
        free(g_ws->S);
        free(g_ws->dtru);
        free(g_ws->DIF);
        free(g_ws->diftru);
        free(g_ws->work);
        free(g_ws->iwork);
        free(g_ws->bwork);
        free(g_ws);
        g_ws = NULL;
    }
    return 0;
}

static void test_ddrgvx(void** state)
{
    (void)state;
    ddrgvx_params_t* params = (ddrgvx_params_t*)(*state);

    const int n = NMAX;
    const int lda = NMAX;
    const f64 ulp = dlamch("P");
    const f64 ulpinv = 1.0 / ulp;
    const f64 thrsh2 = 10.0 * THRESH;

    f64 result[4] = {0.0, 0.0, 0.0, 0.0};

    dlatm6(params->iptype, 5, g_ws->A, lda, g_ws->B,
           g_ws->VR, lda, g_ws->VL, lda,
           WEIGHT[params->iwa], WEIGHT[params->iwb],
           WEIGHT[params->iwx], WEIGHT[params->iwy],
           g_ws->dtru, g_ws->diftru);

    dlacpy("F", n, n, g_ws->A, lda, g_ws->AI, lda);
    dlacpy("F", n, n, g_ws->B, lda, g_ws->BI, lda);

    int ilo, ihi, linfo;
    f64 anorm, bnorm;
    dggevx("N", "V", "V", "B", n, g_ws->AI, lda, g_ws->BI, lda,
           g_ws->alphar, g_ws->alphai, g_ws->beta, g_ws->VL, lda,
           g_ws->VR, lda, &ilo, &ihi, g_ws->lscale, g_ws->rscale,
           &anorm, &bnorm, g_ws->S, g_ws->DIF, g_ws->work, g_ws->lwork,
           g_ws->iwork, g_ws->bwork, &linfo);

    if (linfo != 0) {
        print_message("DGGEVX returned INFO=%d for type=%d iwa=%d iwb=%d iwx=%d iwy=%d\n",
                      linfo, params->iptype, params->iwa + 1,
                      params->iwb + 1, params->iwx + 1, params->iwy + 1);
        result[0] = ulpinv;
        assert_residual_ok(result[0]);
        return;
    }

    /* Compute norm(A, B) */
    dlacpy("Full", n, n, g_ws->AI, lda, g_ws->work, n);
    dlacpy("Full", n, n, g_ws->BI, lda, &g_ws->work[n * n], n);
    f64 abnorm = dlange("Fro", n, 2 * n, g_ws->work, n, g_ws->work);

    /* Test (1): Left eigenvector residual via dget52 */
    f64 res52[2];
    result[0] = 0.0;
    dget52(1, n, g_ws->A, lda, g_ws->B, lda, g_ws->VL, lda,
           g_ws->alphar, g_ws->alphai, g_ws->beta, g_ws->work, res52);
    result[0] = res52[0];
    if (res52[1] > THRESH) {
        print_message("Left eigenvectors from DGGEVX incorrectly normalized: %.3g\n",
                      res52[1]);
    }

    /* Test (2): Right eigenvector residual via dget52 */
    result[1] = 0.0;
    dget52(0, n, g_ws->A, lda, g_ws->B, lda, g_ws->VR, lda,
           g_ws->alphar, g_ws->alphai, g_ws->beta, g_ws->work, res52);
    result[1] = res52[0];
    if (res52[1] > THRESH) {
        print_message("Right eigenvectors from DGGEVX incorrectly normalized: %.3g\n",
                      res52[1]);
    }

    /* Test (3): Eigenvalue condition numbers */
    result[2] = 0.0;
    for (int i = 0; i < n; i++) {
        if (g_ws->S[i] == 0.0) {
            if (g_ws->dtru[i] > abnorm * ulp)
                result[2] = ulpinv;
        } else if (g_ws->dtru[i] == 0.0) {
            if (g_ws->S[i] > abnorm * ulp)
                result[2] = ulpinv;
        } else {
            f64 ratio = fmax(fabs(g_ws->dtru[i] / g_ws->S[i]),
                             fabs(g_ws->S[i] / g_ws->dtru[i]));
            result[2] = fmax(result[2], ratio);
        }
    }

    /* Test (4): Eigenvector condition numbers (1st and 5th) */
    result[3] = 0.0;
    if (g_ws->DIF[0] == 0.0) {
        if (g_ws->diftru[0] > abnorm * ulp)
            result[3] = ulpinv;
    } else if (g_ws->diftru[0] == 0.0) {
        if (g_ws->DIF[0] > abnorm * ulp)
            result[3] = ulpinv;
    } else if (g_ws->DIF[4] == 0.0) {
        if (g_ws->diftru[4] > abnorm * ulp)
            result[3] = ulpinv;
    } else if (g_ws->diftru[4] == 0.0) {
        if (g_ws->DIF[4] > abnorm * ulp)
            result[3] = ulpinv;
    } else {
        f64 ratio1 = fmax(fabs(g_ws->diftru[0] / g_ws->DIF[0]),
                          fabs(g_ws->DIF[0] / g_ws->diftru[0]));
        f64 ratio2 = fmax(fabs(g_ws->diftru[4] / g_ws->DIF[4]),
                          fabs(g_ws->DIF[4] / g_ws->diftru[4]));
        result[3] = fmax(ratio1, ratio2);
    }

    /* Check results against thresholds */
    int any_fail = 0;
    for (int j = 0; j < 4; j++) {
        f64 thr = (j >= 3) ? thrsh2 : THRESH;
        if (result[j] >= thr) {
            print_message("type=%d iwa=%d iwb=%d iwx=%d iwy=%d test(%d)=%g >= %.1f\n",
                          params->iptype, params->iwa + 1, params->iwb + 1,
                          params->iwx + 1, params->iwy + 1, j + 1, result[j], thr);
            any_fail = 1;
        }
    }
    assert_int_equal(any_fail, 0);
}

int main(void)
{
    /* Generate all 1250 parameter combinations */
    static ddrgvx_params_t all_params[2 * 5 * 5 * 5 * 5];
    static struct CMUnitTest all_tests[2 * 5 * 5 * 5 * 5];
    int idx = 0;

    for (int iptype = 1; iptype <= 2; iptype++) {
        for (int iwa = 0; iwa < 5; iwa++) {
            for (int iwb = 0; iwb < 5; iwb++) {
                for (int iwx = 0; iwx < 5; iwx++) {
                    for (int iwy = 0; iwy < 5; iwy++) {
                        ddrgvx_params_t* p = &all_params[idx];
                        p->iptype = iptype;
                        p->iwa = iwa;
                        p->iwb = iwb;
                        p->iwx = iwx;
                        p->iwy = iwy;
                        snprintf(p->name, sizeof(p->name),
                                 "type=%d_wa=%d_wb=%d_wx=%d_wy=%d",
                                 iptype, iwa + 1, iwb + 1, iwx + 1, iwy + 1);

                        all_tests[idx].name = p->name;
                        all_tests[idx].test_func = test_ddrgvx;
                        all_tests[idx].setup_func = NULL;
                        all_tests[idx].teardown_func = NULL;
                        all_tests[idx].initial_state = p;
                        idx++;
                    }
                }
            }
        }
    }

    return cmocka_run_group_tests_name("ddrgvx", all_tests, group_setup,
                                       group_teardown);
}
