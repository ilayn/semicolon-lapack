/* AUTO-GENERATED FILE â€” DO NOT EDIT
 * Fortran-ABI compatibility shim for semicolon-lapack
 * Precision: complex_single
 * Source header: semicolon_lapack_complex_single.h
 * Generated by scripts/generate_fortran_shim.py
 */

#include <stdlib.h>
#include "semicolon_lapack_complex_single.h"


f32 scsum1_(INT* n, c64* CX, INT* incx) {
    f32 _ret = scsum1(*n, CX, *incx);
    return _ret;
}

f32 cla_gbrpvgrw_(INT* n, INT* kl, INT* ku, INT* ncols, c64* AB, INT* ldab, c64* AFB, INT* ldafb) {
    f32 _ret = cla_gbrpvgrw(*n, *kl, *ku, *ncols, AB, *ldab, AFB, *ldafb);
    return _ret;
}

f32 cla_gerpvgrw_(INT* n, INT* ncols, c64* A, INT* lda, c64* AF, INT* ldaf) {
    f32 _ret = cla_gerpvgrw(*n, *ncols, A, *lda, AF, *ldaf);
    return _ret;
}

c64 cladiv_(c64* X, c64* Y) {
    c64 _ret = cladiv(*X, *Y);
    return _ret;
}

f32 clangb_(char* norm, INT* n, INT* kl, INT* ku, c64* AB, INT* ldab, f32* work) {
    f32 _ret = clangb(norm, *n, *kl, *ku, AB, *ldab, work);
    return _ret;
}

f32 clange_(char* norm, INT* m, INT* n, c64* A, INT* lda, f32* work) {
    f32 _ret = clange(norm, *m, *n, A, *lda, work);
    return _ret;
}

f32 clangt_(char* norm, INT* n, c64* DL, c64* D, c64* DU) {
    f32 _ret = clangt(norm, *n, DL, D, DU);
    return _ret;
}

f32 clanhb_(char* norm, char* uplo, INT* n, INT* k, c64* AB, INT* ldab, f32* work) {
    f32 _ret = clanhb(norm, uplo, *n, *k, AB, *ldab, work);
    return _ret;
}

f32 clanhe_(char* norm, char* uplo, INT* n, c64* A, INT* lda, f32* work) {
    f32 _ret = clanhe(norm, uplo, *n, A, *lda, work);
    return _ret;
}

f32 clanhf_(char* norm, char* transr, char* uplo, INT* n, c64* A, f32* work) {
    f32 _ret = clanhf(norm, transr, uplo, *n, A, work);
    return _ret;
}

f32 clanhp_(char* norm, char* uplo, INT* n, c64* AP, f32* work) {
    f32 _ret = clanhp(norm, uplo, *n, AP, work);
    return _ret;
}

f32 clanhs_(char* norm, INT* n, c64* A, INT* lda, f32* work) {
    f32 _ret = clanhs(norm, *n, A, *lda, work);
    return _ret;
}

f32 clanht_(char* norm, INT* n, f32* D, c64* E) {
    f32 _ret = clanht(norm, *n, D, E);
    return _ret;
}

f32 clansb_(char* norm, char* uplo, INT* n, INT* k, c64* AB, INT* ldab, f32* work) {
    f32 _ret = clansb(norm, uplo, *n, *k, AB, *ldab, work);
    return _ret;
}

f32 clansp_(char* norm, char* uplo, INT* n, c64* AP, f32* work) {
    f32 _ret = clansp(norm, uplo, *n, AP, work);
    return _ret;
}

f32 clansy_(char* norm, char* uplo, INT* n, c64* A, INT* lda, f32* work) {
    f32 _ret = clansy(norm, uplo, *n, A, *lda, work);
    return _ret;
}

f32 clantb_(char* norm, char* uplo, char* diag, INT* n, INT* k, c64* AB, INT* ldab, f32* work) {
    f32 _ret = clantb(norm, uplo, diag, *n, *k, AB, *ldab, work);
    return _ret;
}

f32 clantp_(char* norm, char* uplo, char* diag, INT* n, c64* AP, f32* work) {
    f32 _ret = clantp(norm, uplo, diag, *n, AP, work);
    return _ret;
}

f32 clantr_(char* norm, char* uplo, char* diag, INT* m, INT* n, c64* A, INT* lda, f32* work) {
    f32 _ret = clantr(norm, uplo, diag, *m, *n, A, *lda, work);
    return _ret;
}

INT icmax1_(INT* n, c64* ZX, INT* incx) {
    INT _ret = icmax1(*n, ZX, *incx);
    return _ret;
}

void cbbcsd_(char* jobu1, char* jobu2, char* jobv1t, char* jobv2t, char* trans, INT* m, INT* p, INT* q, f32* theta, f32* phi, c64* U1, INT* ldu1, c64* U2, INT* ldu2, c64* V1T, INT* ldv1t, c64* V2T, INT* ldv2t, f32* B11D, f32* B11E, f32* B12D, f32* B12E, f32* B21D, f32* B21E, f32* B22D, f32* B22E, f32* rwork, INT* lrwork, INT* info) {
    cbbcsd(jobu1, jobu2, jobv1t, jobv2t, trans, *m, *p, *q, theta, phi, U1, *ldu1, U2, *ldu2, V1T, *ldv1t, V2T, *ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, rwork, *lrwork, info);
}

void cbdsqr_(char* uplo, INT* n, INT* ncvt, INT* nru, INT* ncc, f32* D, f32* E, c64* VT, INT* ldvt, c64* U, INT* ldu, c64* C, INT* ldc, f32* rwork, INT* info) {
    cbdsqr(uplo, *n, *ncvt, *nru, *ncc, D, E, VT, *ldvt, U, *ldu, C, *ldc, rwork, info);
}

void cdrscl_(INT* n, f32* sa, c64* sx, INT* incx) {
    cdrscl(*n, *sa, sx, *incx);
}

void cgbcon_(char* norm, INT* n, INT* kl, INT* ku, c64* AB, INT* ldab, INT* ipiv, f32* anorm, f32* rcond, c64* work, f32* rwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cgbcon(norm, *n, *kl, *ku, AB, *ldab, _ipiv0, *anorm, rcond, work, rwork, info);
    free(_ipiv0);
}

void cgbequ_(INT* m, INT* n, INT* kl, INT* ku, c64* AB, INT* ldab, f32* R, f32* C, f32* rowcnd, f32* colcnd, f32* amax, INT* info) {
    cgbequ(*m, *n, *kl, *ku, AB, *ldab, R, C, rowcnd, colcnd, amax, info);
}

void cgbequb_(INT* m, INT* n, INT* kl, INT* ku, c64* AB, INT* ldab, f32* R, f32* C, f32* rowcnd, f32* colcnd, f32* amax, INT* info) {
    cgbequb(*m, *n, *kl, *ku, AB, *ldab, R, C, rowcnd, colcnd, amax, info);
}

void cgbrfs_(char* trans, INT* n, INT* kl, INT* ku, INT* nrhs, c64* AB, INT* ldab, c64* AFB, INT* ldafb, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cgbrfs(trans, *n, *kl, *ku, *nrhs, AB, *ldab, AFB, *ldafb, _ipiv0, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
    free(_ipiv0);
}

void cgbsv_(INT* n, INT* kl, INT* ku, INT* nrhs, c64* AB, INT* ldab, INT* ipiv, c64* B, INT* ldb, INT* info) {
    cgbsv(*n, *kl, *ku, *nrhs, AB, *ldab, ipiv, B, *ldb, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void cgbsvx_(char* fact, char* trans, INT* n, INT* kl, INT* ku, INT* nrhs, c64* AB, INT* ldab, c64* AFB, INT* ldafb, INT* ipiv, char* equed, f32* R, f32* C, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    if (fact[0] == 'F' || fact[0] == 'f') {
        INT* _ipiv0 = NULL;
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
        cgbsvx(fact, trans, *n, *kl, *ku, *nrhs, AB, *ldab, AFB, *ldafb, _ipiv0, equed, R, C, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        free(_ipiv0);
    } else {
        cgbsvx(fact, trans, *n, *kl, *ku, *nrhs, AB, *ldab, AFB, *ldafb, ipiv, equed, R, C, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void cgbbrd_(char* vect, INT* m, INT* n, INT* ncc, INT* kl, INT* ku, c64* AB, INT* ldab, f32* D, f32* E, c64* Q, INT* ldq, c64* PT, INT* ldpt, c64* C, INT* ldc, c64* work, f32* rwork, INT* info) {
    cgbbrd(vect, *m, *n, *ncc, *kl, *ku, AB, *ldab, D, E, Q, *ldq, PT, *ldpt, C, *ldc, work, rwork, info);
}

void cgbtf2_(INT* m, INT* n, INT* kl, INT* ku, c64* AB, INT* ldab, INT* ipiv, INT* info) {
    cgbtf2(*m, *n, *kl, *ku, AB, *ldab, ipiv, info);
    if (ipiv) { INT _sz = ((*m < *n) ? *m : *n); for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void cgbtrf_(INT* m, INT* n, INT* kl, INT* ku, c64* AB, INT* ldab, INT* ipiv, INT* info) {
    cgbtrf(*m, *n, *kl, *ku, AB, *ldab, ipiv, info);
    if (ipiv) { INT _sz = ((*m < *n) ? *m : *n); for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void cgbtrs_(char* trans, INT* n, INT* kl, INT* ku, INT* nrhs, c64* AB, INT* ldab, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cgbtrs(trans, *n, *kl, *ku, *nrhs, AB, *ldab, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void cgebak_(char* job, char* side, INT* n, INT* ilo, INT* ihi, f32* scale, INT* m, c64* V, INT* ldv, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    if (job[0] == 'B' || job[0] == 'b' || job[0] == 'P' || job[0] == 'p') {
        for (INT _i = 0; _i < *ilo - 1; _i++) scale[_i] -= 1.0;
        for (INT _i = *ihi; _i < *n; _i++) scale[_i] -= 1.0;
    }
    cgebak(job, side, *n, _ilo, _ihi, scale, *m, V, *ldv, info);
    if (job[0] == 'B' || job[0] == 'b' || job[0] == 'P' || job[0] == 'p') {
        for (INT _i = 0; _i < *ilo - 1; _i++) scale[_i] += 1.0;
        for (INT _i = *ihi; _i < *n; _i++) scale[_i] += 1.0;
    }
}

void cgebal_(char* job, INT* n, c64* A, INT* lda, INT* ilo, INT* ihi, f32* scale, INT* info) {
    cgebal(job, *n, A, *lda, ilo, ihi, scale, info);
    (*ilo)++;
    (*ihi)++;
    for (INT _i = 0; _i < *ilo - 1; _i++) scale[_i] += 1.0;
    for (INT _i = *ihi; _i < *n; _i++) scale[_i] += 1.0;
}

void cgebd2_(INT* m, INT* n, c64* A, INT* lda, f32* D, f32* E, c64* tauq, c64* taup, c64* work, INT* info) {
    cgebd2(*m, *n, A, *lda, D, E, tauq, taup, work, info);
}

void cgebrd_(INT* m, INT* n, c64* A, INT* lda, f32* D, f32* E, c64* tauq, c64* taup, c64* work, INT* lwork, INT* info) {
    cgebrd(*m, *n, A, *lda, D, E, tauq, taup, work, *lwork, info);
}

void cgecon_(char* norm, INT* n, c64* A, INT* lda, f32* anorm, f32* rcond, c64* work, f32* rwork, INT* info) {
    cgecon(norm, *n, A, *lda, *anorm, rcond, work, rwork, info);
}

void cgeequ_(INT* m, INT* n, c64* A, INT* lda, f32* R, f32* C, f32* rowcnd, f32* colcnd, f32* amax, INT* info) {
    cgeequ(*m, *n, A, *lda, R, C, rowcnd, colcnd, amax, info);
}

void cgeequb_(INT* m, INT* n, c64* A, INT* lda, f32* R, f32* C, f32* rowcnd, f32* colcnd, f32* amax, INT* info) {
    cgeequb(*m, *n, A, *lda, R, C, rowcnd, colcnd, amax, info);
}

void cgees_(char* jobvs, char* sort, cselect1_t select, INT* n, c64* A, INT* lda, INT* sdim, c64* W, c64* VS, INT* ldvs, c64* work, INT* lwork, f32* rwork, INT* bwork, INT* info) {
    cgees(jobvs, sort, select, *n, A, *lda, sdim, W, VS, *ldvs, work, *lwork, rwork, bwork, info);
}

void cgeesx_(char* jobvs, char* sort, cselect1_t select, char* sense, INT* n, c64* A, INT* lda, INT* sdim, c64* W, c64* VS, INT* ldvs, f32* rconde, f32* rcondv, c64* work, INT* lwork, f32* rwork, INT* bwork, INT* info) {
    cgeesx(jobvs, sort, select, sense, *n, A, *lda, sdim, W, VS, *ldvs, rconde, rcondv, work, *lwork, rwork, bwork, info);
}

void cgeev_(char* jobvl, char* jobvr, INT* n, c64* A, INT* lda, c64* W, c64* VL, INT* ldvl, c64* VR, INT* ldvr, c64* work, INT* lwork, f32* rwork, INT* info) {
    cgeev(jobvl, jobvr, *n, A, *lda, W, VL, *ldvl, VR, *ldvr, work, *lwork, rwork, info);
}

void cgeevx_(char* balanc, char* jobvl, char* jobvr, char* sense, INT* n, c64* A, INT* lda, c64* W, c64* VL, INT* ldvl, c64* VR, INT* ldvr, INT* ilo, INT* ihi, f32* scale, f32* abnrm, f32* rconde, f32* rcondv, c64* work, INT* lwork, f32* rwork, INT* info) {
    cgeevx(balanc, jobvl, jobvr, sense, *n, A, *lda, W, VL, *ldvl, VR, *ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, *lwork, rwork, info);
    (*ilo)++;
    (*ihi)++;
}

void cgehd2_(INT* n, INT* ilo, INT* ihi, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    cgehd2(*n, _ilo, _ihi, A, *lda, tau, work, info);
}

void cgehrd_(INT* n, INT* ilo, INT* ihi, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    cgehrd(*n, _ilo, _ihi, A, *lda, tau, work, *lwork, info);
}

void cgelq_(INT* m, INT* n, c64* A, INT* lda, c64* T, INT* tsize, c64* work, INT* lwork, INT* info) {
    cgelq(*m, *n, A, *lda, T, *tsize, work, *lwork, info);
}

void cgelq2_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    cgelq2(*m, *n, A, *lda, tau, work, info);
}

void cgelqf_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cgelqf(*m, *n, A, *lda, tau, work, *lwork, info);
}

void cgelqt_(INT* m, INT* n, INT* mb, c64* A, INT* lda, c64* T, INT* ldt, c64* work, INT* info) {
    cgelqt(*m, *n, *mb, A, *lda, T, *ldt, work, info);
}

void cgelqt3_(INT* m, INT* n, c64* A, INT* lda, c64* T, INT* ldt, INT* info) {
    cgelqt3(*m, *n, A, *lda, T, *ldt, info);
}

void cgels_(char* trans, INT* m, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    cgels(trans, *m, *n, *nrhs, A, *lda, B, *ldb, work, *lwork, info);
}

void cgelsd_(INT* m, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, f32* S, f32* rcond, INT* rank, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* info) {
    cgelsd(*m, *n, *nrhs, A, *lda, B, *ldb, S, *rcond, rank, work, *lwork, rwork, iwork, info);
}

void cgelst_(char* trans, INT* m, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    cgelst(trans, *m, *n, *nrhs, A, *lda, B, *ldb, work, *lwork, info);
}

void cgelss_(INT* m, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, f32* S, f32* rcond, INT* rank, c64* work, INT* lwork, f32* rwork, INT* info) {
    cgelss(*m, *n, *nrhs, A, *lda, B, *ldb, S, *rcond, rank, work, *lwork, rwork, info);
}

void cgelsy_(INT* m, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, INT* jpvt, f32* rcond, INT* rank, c64* work, INT* lwork, f32* rwork, INT* info) {
    INT* _jpvt0 = NULL;
    if (*lwork != -1) {
        if (jpvt) {
            INT _jpvt_sz = *n;
            _jpvt0 = (INT*)malloc(_jpvt_sz * sizeof(INT));
            for (INT _i = 0; _i < _jpvt_sz; _i++) _jpvt0[_i] = (jpvt[_i] > 0) ? jpvt[_i] - 1 : jpvt[_i];
        }
    }
    if (*lwork != -1) {
        cgelsy(*m, *n, *nrhs, A, *lda, B, *ldb, _jpvt0, *rcond, rank, work, *lwork, rwork, info);
    } else {
        cgelsy(*m, *n, *nrhs, A, *lda, B, *ldb, jpvt, *rcond, rank, work, *lwork, rwork, info);
    }
    if (*lwork != -1) {
        free(_jpvt0);
    }
}

void cgemlq_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* T, INT* tsize, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cgemlq(side, trans, *m, *n, *k, A, *lda, T, *tsize, C, *ldc, work, *lwork, info);
}

void cgemlqt_(char* side, char* trans, INT* m, INT* n, INT* k, INT* mb, c64* V, INT* ldv, c64* T, INT* ldt, c64* C, INT* ldc, c64* work, INT* info) {
    cgemlqt(side, trans, *m, *n, *k, *mb, V, *ldv, T, *ldt, C, *ldc, work, info);
}

void cgemqr_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* T, INT* tsize, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cgemqr(side, trans, *m, *n, *k, A, *lda, T, *tsize, C, *ldc, work, *lwork, info);
}

void cgemqrt_(char* side, char* trans, INT* m, INT* n, INT* k, INT* nb, c64* V, INT* ldv, c64* T, INT* ldt, c64* C, INT* ldc, c64* work, INT* info) {
    cgemqrt(side, trans, *m, *n, *k, *nb, V, *ldv, T, *ldt, C, *ldc, work, info);
}

void cgeql2_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    cgeql2(*m, *n, A, *lda, tau, work, info);
}

void cgeqlf_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cgeqlf(*m, *n, A, *lda, tau, work, *lwork, info);
}

void cgeqp3_(INT* m, INT* n, c64* A, INT* lda, INT* jpvt, c64* tau, c64* work, INT* lwork, f32* rwork, INT* info) {
    cgeqp3(*m, *n, A, *lda, jpvt, tau, work, *lwork, rwork, info);
    if (*lwork != -1) {
        if (jpvt) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (jpvt[_i] >= 0) jpvt[_i]++; } }
    }
}

void cgeqp3rk_(INT* m, INT* n, INT* nrhs, INT* kmax, f32* abstol, f32* reltol, c64* A, INT* lda, INT* K, f32* maxc2nrmk, f32* relmaxc2nrmk, INT* jpiv, c64* tau, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* info) {
    cgeqp3rk(*m, *n, *nrhs, *kmax, *abstol, *reltol, A, *lda, K, maxc2nrmk, relmaxc2nrmk, jpiv, tau, work, *lwork, rwork, iwork, info);
    if (*lwork != -1) {
        if (jpiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (jpiv[_i] >= 0) jpiv[_i]++; } }
    }
}

void cgeqr_(INT* m, INT* n, c64* A, INT* lda, c64* T, INT* tsize, c64* work, INT* lwork, INT* info) {
    cgeqr(*m, *n, A, *lda, T, *tsize, work, *lwork, info);
}

void cgeqr2_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    cgeqr2(*m, *n, A, *lda, tau, work, info);
}

void cgeqr2p_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    cgeqr2p(*m, *n, A, *lda, tau, work, info);
}

void cgeqrf_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cgeqrf(*m, *n, A, *lda, tau, work, *lwork, info);
}

void cgeqrfp_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cgeqrfp(*m, *n, A, *lda, tau, work, *lwork, info);
}

void cgeqrt_(INT* m, INT* n, INT* nb, c64* A, INT* lda, c64* T, INT* ldt, c64* work, INT* info) {
    cgeqrt(*m, *n, *nb, A, *lda, T, *ldt, work, info);
}

void cgeqrt2_(INT* m, INT* n, c64* A, INT* lda, c64* T, INT* ldt, INT* info) {
    cgeqrt2(*m, *n, A, *lda, T, *ldt, info);
}

void cgeqrt3_(INT* m, INT* n, c64* A, INT* lda, c64* T, INT* ldt, INT* info) {
    cgeqrt3(*m, *n, A, *lda, T, *ldt, info);
}

void cgerfs_(char* trans, INT* n, INT* nrhs, c64* A, INT* lda, c64* AF, INT* ldaf, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cgerfs(trans, *n, *nrhs, A, *lda, AF, *ldaf, _ipiv0, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
    free(_ipiv0);
}

void cgerq2_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    cgerq2(*m, *n, A, *lda, tau, work, info);
}

void cgerqf_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cgerqf(*m, *n, A, *lda, tau, work, *lwork, info);
}

void cgesc2_(INT* n, c64* A, INT* lda, c64* rhs, INT* ipiv, INT* jpiv, f32* scale) {
    INT* _ipiv0 = NULL;
    INT* _jpiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    if (jpiv) {
        INT _jpiv_sz = *n;
        _jpiv0 = (INT*)malloc(_jpiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _jpiv_sz; _i++) _jpiv0[_i] = (jpiv[_i] > 0) ? jpiv[_i] - 1 : jpiv[_i];
    }
    cgesc2(*n, A, *lda, rhs, _ipiv0, _jpiv0, scale);
    free(_ipiv0);
    free(_jpiv0);
}

void cgesv_(INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, INT* info) {
    cgesv(*n, *nrhs, A, *lda, ipiv, B, *ldb, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void cgejsv_(char* joba, char* jobu, char* jobv, char* jobr, char* jobt, char* jobp, INT* m, INT* n, c64* A, INT* lda, f32* SVA, c64* U, INT* ldu, c64* V, INT* ldv, c64* cwork, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* info) {
    cgejsv(joba, jobu, jobv, jobr, jobt, jobp, *m, *n, A, *lda, SVA, U, *ldu, V, *ldv, cwork, *lwork, rwork, *lrwork, iwork, info);
}

void cgesvj_(char* joba, char* jobu, char* jobv, INT* m, INT* n, c64* A, INT* lda, f32* SVA, INT* mv, c64* V, INT* ldv, c64* cwork, INT* lwork, f32* rwork, INT* lrwork, INT* info) {
    cgesvj(joba, jobu, jobv, *m, *n, A, *lda, SVA, *mv, V, *ldv, cwork, *lwork, rwork, *lrwork, info);
}

void cgesdd_(char* jobz, INT* m, INT* n, c64* A, INT* lda, f32* S, c64* U, INT* ldu, c64* VT, INT* ldvt, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* info) {
    cgesdd(jobz, *m, *n, A, *lda, S, U, *ldu, VT, *ldvt, work, *lwork, rwork, iwork, info);
}

void cgesvd_(char* jobu, char* jobvt, INT* m, INT* n, c64* A, INT* lda, f32* S, c64* U, INT* ldu, c64* VT, INT* ldvt, c64* work, INT* lwork, f32* rwork, INT* info) {
    cgesvd(jobu, jobvt, *m, *n, A, *lda, S, U, *ldu, VT, *ldvt, work, *lwork, rwork, info);
}

void cgesvdq_(char* joba, char* jobp, char* jobr, char* jobu, char* jobv, INT* m, INT* n, c64* A, INT* lda, f32* S, c64* U, INT* ldu, c64* V, INT* ldv, INT* numrank, INT* iwork, INT* liwork, c64* cwork, INT* lcwork, f32* rwork, INT* lrwork, INT* info) {
    cgesvdq(joba, jobp, jobr, jobu, jobv, *m, *n, A, *lda, S, U, *ldu, V, *ldv, numrank, iwork, *liwork, cwork, *lcwork, rwork, *lrwork, info);
}

void cgesvdx_(char* jobu, char* jobvt, char* range, INT* m, INT* n, c64* A, INT* lda, f32* vl, f32* vu, INT* il, INT* iu, INT* ns, f32* S, c64* U, INT* ldu, c64* VT, INT* ldvt, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    cgesvdx(jobu, jobvt, range, *m, *n, A, *lda, *vl, *vu, _il, _iu, ns, S, U, *ldu, VT, *ldvt, work, *lwork, rwork, iwork, info);
}

void cgesvx_(char* fact, char* trans, INT* n, INT* nrhs, c64* A, INT* lda, c64* AF, INT* ldaf, INT* ipiv, char* equed, f32* R, f32* C, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    if (fact[0] == 'F' || fact[0] == 'f') {
        INT* _ipiv0 = NULL;
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
        cgesvx(fact, trans, *n, *nrhs, A, *lda, AF, *ldaf, _ipiv0, equed, R, C, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        free(_ipiv0);
    } else {
        cgesvx(fact, trans, *n, *nrhs, A, *lda, AF, *ldaf, ipiv, equed, R, C, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void cgetc2_(INT* n, c64* A, INT* lda, INT* ipiv, INT* jpiv, INT* info) {
    cgetc2(*n, A, *lda, ipiv, jpiv, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    if (jpiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (jpiv[_i] >= 0) jpiv[_i]++; } }
}

void cgetf2_(INT* m, INT* n, c64* A, INT* lda, INT* ipiv, INT* info) {
    cgetf2(*m, *n, A, *lda, ipiv, info);
    if (ipiv) { INT _sz = ((*m < *n) ? *m : *n); for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void cgetrf_(INT* m, INT* n, c64* A, INT* lda, INT* ipiv, INT* info) {
    cgetrf(*m, *n, A, *lda, ipiv, info);
    if (ipiv) { INT _sz = ((*m < *n) ? *m : *n); for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void cgetrf2_(INT* m, INT* n, c64* A, INT* lda, INT* ipiv, INT* info) {
    cgetrf2(*m, *n, A, *lda, ipiv, info);
    if (ipiv) { INT _sz = ((*m < *n) ? *m : *n); for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void cgetri_(INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* lwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (*lwork != -1) {
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
    }
    if (*lwork != -1) {
        cgetri(*n, A, *lda, _ipiv0, work, *lwork, info);
    } else {
        cgetri(*n, A, *lda, ipiv, work, *lwork, info);
    }
    if (*lwork != -1) {
        free(_ipiv0);
    }
}

void cgetrs_(char* trans, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cgetrs(trans, *n, *nrhs, A, *lda, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void cgetsls_(char* trans, INT* m, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    cgetsls(trans, *m, *n, *nrhs, A, *lda, B, *ldb, work, *lwork, info);
}

void cgetsqrhrt_(INT* m, INT* n, INT* mb1, INT* nb1, INT* nb2, c64* A, INT* lda, c64* T, INT* ldt, c64* work, INT* lwork, INT* info) {
    cgetsqrhrt(*m, *n, *mb1, *nb1, *nb2, A, *lda, T, *ldt, work, *lwork, info);
}

void cggbak_(char* job, char* side, INT* n, INT* ilo, INT* ihi, f32* lscale, f32* rscale, INT* m, c64* V, INT* ldv, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    cggbak(job, side, *n, _ilo, _ihi, lscale, rscale, *m, V, *ldv, info);
}

void cggbal_(char* job, INT* n, c64* A, INT* lda, c64* B, INT* ldb, INT* ilo, INT* ihi, f32* lscale, f32* rscale, f32* work, INT* info) {
    cggbal(job, *n, A, *lda, B, *ldb, ilo, ihi, lscale, rscale, work, info);
    (*ilo)++;
    (*ihi)++;
}

void cggglm_(INT* n, INT* m, INT* p, c64* A, INT* lda, c64* B, INT* ldb, c64* D, c64* X, c64* Y, c64* work, INT* lwork, INT* info) {
    cggglm(*n, *m, *p, A, *lda, B, *ldb, D, X, Y, work, *lwork, info);
}

void cgges_(char* jobvsl, char* jobvsr, char* sort, cselect2_t selctg, INT* n, c64* A, INT* lda, c64* B, INT* ldb, INT* sdim, c64* alpha, c64* beta, c64* VSL, INT* ldvsl, c64* VSR, INT* ldvsr, c64* work, INT* lwork, f32* rwork, INT* bwork, INT* info) {
    cgges(jobvsl, jobvsr, sort, selctg, *n, A, *lda, B, *ldb, sdim, alpha, beta, VSL, *ldvsl, VSR, *ldvsr, work, *lwork, rwork, bwork, info);
}

void cgges3_(char* jobvsl, char* jobvsr, char* sort, cselect2_t selctg, INT* n, c64* A, INT* lda, c64* B, INT* ldb, INT* sdim, c64* alpha, c64* beta, c64* VSL, INT* ldvsl, c64* VSR, INT* ldvsr, c64* work, INT* lwork, f32* rwork, INT* bwork, INT* info) {
    cgges3(jobvsl, jobvsr, sort, selctg, *n, A, *lda, B, *ldb, sdim, alpha, beta, VSL, *ldvsl, VSR, *ldvsr, work, *lwork, rwork, bwork, info);
}

void cggesx_(char* jobvsl, char* jobvsr, char* sort, cselect2_t selctg, char* sense, INT* n, c64* A, INT* lda, c64* B, INT* ldb, INT* sdim, c64* alpha, c64* beta, c64* VSL, INT* ldvsl, c64* VSR, INT* ldvsr, f32* rconde, f32* rcondv, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* liwork, INT* bwork, INT* info) {
    cggesx(jobvsl, jobvsr, sort, selctg, sense, *n, A, *lda, B, *ldb, sdim, alpha, beta, VSL, *ldvsl, VSR, *ldvsr, rconde, rcondv, work, *lwork, rwork, iwork, *liwork, bwork, info);
}

void cggev_(char* jobvl, char* jobvr, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* alpha, c64* beta, c64* VL, INT* ldvl, c64* VR, INT* ldvr, c64* work, INT* lwork, f32* rwork, INT* info) {
    cggev(jobvl, jobvr, *n, A, *lda, B, *ldb, alpha, beta, VL, *ldvl, VR, *ldvr, work, *lwork, rwork, info);
}

void cggev3_(char* jobvl, char* jobvr, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* alpha, c64* beta, c64* VL, INT* ldvl, c64* VR, INT* ldvr, c64* work, INT* lwork, f32* rwork, INT* info) {
    cggev3(jobvl, jobvr, *n, A, *lda, B, *ldb, alpha, beta, VL, *ldvl, VR, *ldvr, work, *lwork, rwork, info);
}

void cggevx_(char* balanc, char* jobvl, char* jobvr, char* sense, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* alpha, c64* beta, c64* VL, INT* ldvl, c64* VR, INT* ldvr, INT* ilo, INT* ihi, f32* lscale, f32* rscale, f32* abnrm, f32* bbnrm, f32* rconde, f32* rcondv, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* bwork, INT* info) {
    cggevx(balanc, jobvl, jobvr, sense, *n, A, *lda, B, *ldb, alpha, beta, VL, *ldvl, VR, *ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, *lwork, rwork, iwork, bwork, info);
    (*ilo)++;
    (*ihi)++;
}

void cgghd3_(char* compq, char* compz, INT* n, INT* ilo, INT* ihi, c64* A, INT* lda, c64* B, INT* ldb, c64* Q, INT* ldq, c64* Z, INT* ldz, c64* work, INT* lwork, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    cgghd3(compq, compz, *n, _ilo, _ihi, A, *lda, B, *ldb, Q, *ldq, Z, *ldz, work, *lwork, info);
}

void cgghrd_(char* compq, char* compz, INT* n, INT* ilo, INT* ihi, c64* A, INT* lda, c64* B, INT* ldb, c64* Q, INT* ldq, c64* Z, INT* ldz, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    cgghrd(compq, compz, *n, _ilo, _ihi, A, *lda, B, *ldb, Q, *ldq, Z, *ldz, info);
}

void cggsvd3_(char* jobu, char* jobv, char* jobq, INT* m, INT* n, INT* p, INT* k, INT* l, c64* A, INT* lda, c64* B, INT* ldb, f32* alpha, f32* beta, c64* U, INT* ldu, c64* V, INT* ldv, c64* Q, INT* ldq, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* info) {
    cggsvd3(jobu, jobv, jobq, *m, *n, *p, k, l, A, *lda, B, *ldb, alpha, beta, U, *ldu, V, *ldv, Q, *ldq, work, *lwork, rwork, iwork, info);
}

void cggsvp3_(char* jobu, char* jobv, char* jobq, INT* m, INT* p, INT* n, c64* A, INT* lda, c64* B, INT* ldb, f32* tola, f32* tolb, INT* k, INT* l, c64* U, INT* ldu, c64* V, INT* ldv, c64* Q, INT* ldq, INT* iwork, f32* rwork, c64* tau, c64* work, INT* lwork, INT* info) {
    cggsvp3(jobu, jobv, jobq, *m, *p, *n, A, *lda, B, *ldb, *tola, *tolb, k, l, U, *ldu, V, *ldv, Q, *ldq, iwork, rwork, tau, work, *lwork, info);
}

void cgglse_(INT* m, INT* n, INT* p, c64* A, INT* lda, c64* B, INT* ldb, c64* C, c64* D, c64* X, c64* work, INT* lwork, INT* info) {
    cgglse(*m, *n, *p, A, *lda, B, *ldb, C, D, X, work, *lwork, info);
}

void cggqrf_(INT* n, INT* m, INT* p, c64* A, INT* lda, c64* taua, c64* B, INT* ldb, c64* taub, c64* work, INT* lwork, INT* info) {
    cggqrf(*n, *m, *p, A, *lda, taua, B, *ldb, taub, work, *lwork, info);
}

void cggrqf_(INT* m, INT* p, INT* n, c64* A, INT* lda, c64* taua, c64* B, INT* ldb, c64* taub, c64* work, INT* lwork, INT* info) {
    cggrqf(*m, *p, *n, A, *lda, taua, B, *ldb, taub, work, *lwork, info);
}

void cgsvj0_(char* jobv, INT* m, INT* n, c64* A, INT* lda, c64* D, f32* SVA, INT* mv, c64* V, INT* ldv, f32* eps, f32* sfmin, f32* tol, INT* nsweep, c64* work, INT* lwork, INT* info) {
    cgsvj0(jobv, *m, *n, A, *lda, D, SVA, *mv, V, *ldv, *eps, *sfmin, *tol, *nsweep, work, *lwork, info);
}

void cgsvj1_(char* jobv, INT* m, INT* n, INT* n1, c64* A, INT* lda, c64* D, f32* SVA, INT* mv, c64* V, INT* ldv, f32* eps, f32* sfmin, f32* tol, INT* nsweep, c64* work, INT* lwork, INT* info) {
    cgsvj1(jobv, *m, *n, *n1, A, *lda, D, SVA, *mv, V, *ldv, *eps, *sfmin, *tol, *nsweep, work, *lwork, info);
}

void cgtcon_(char* norm, INT* n, c64* DL, c64* D, c64* DU, c64* DU2, INT* ipiv, f32* anorm, f32* rcond, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cgtcon(norm, *n, DL, D, DU, DU2, _ipiv0, *anorm, rcond, work, info);
    free(_ipiv0);
}

void cgtrfs_(char* trans, INT* n, INT* nrhs, c64* DL, c64* D, c64* DU, c64* DLF, c64* DF, c64* DUF, c64* DU2, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cgtrfs(trans, *n, *nrhs, DL, D, DU, DLF, DF, DUF, DU2, _ipiv0, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
    free(_ipiv0);
}

void cgtsv_(INT* n, INT* nrhs, c64* DL, c64* D, c64* DU, c64* B, INT* ldb, INT* info) {
    cgtsv(*n, *nrhs, DL, D, DU, B, *ldb, info);
}

void cgtsvx_(char* fact, char* trans, INT* n, INT* nrhs, c64* DL, c64* D, c64* DU, c64* DLF, c64* DF, c64* DUF, c64* DU2, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    if (fact[0] == 'F' || fact[0] == 'f') {
        INT* _ipiv0 = NULL;
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
        cgtsvx(fact, trans, *n, *nrhs, DL, D, DU, DLF, DF, DUF, DU2, _ipiv0, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        free(_ipiv0);
    } else {
        cgtsvx(fact, trans, *n, *nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void cgttrf_(INT* n, c64* DL, c64* D, c64* DU, c64* DU2, INT* ipiv, INT* info) {
    cgttrf(*n, DL, D, DU, DU2, ipiv, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void cgttrs_(char* trans, INT* n, INT* nrhs, c64* DL, c64* D, c64* DU, c64* DU2, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cgttrs(trans, *n, *nrhs, DL, D, DU, DU2, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void cgtts2_(INT* itrans, INT* n, INT* nrhs, c64* DL, c64* D, c64* DU, c64* DU2, INT* ipiv, c64* B, INT* ldb) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cgtts2(*itrans, *n, *nrhs, DL, D, DU, DU2, _ipiv0, B, *ldb);
    free(_ipiv0);
}

void chb2st_kernels_(char* uplo, INT* wantz, INT* ttype, INT* st, INT* ed, INT* sweep, INT* n, INT* nb, INT* ib, c64* A, INT* lda, c64* V, c64* TAU, INT* ldvt, c64* WORK) {
    chb2st_kernels(uplo, *wantz, *ttype, *st, *ed, *sweep, *n, *nb, *ib, A, *lda, V, TAU, *ldvt, WORK);
}

void chbev_(char* jobz, char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* W, c64* Z, INT* ldz, c64* work, f32* rwork, INT* info) {
    chbev(jobz, uplo, *n, *kd, AB, *ldab, W, Z, *ldz, work, rwork, info);
}

void chbev_2stage_(char* jobz, char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* info) {
    chbev_2stage(jobz, uplo, *n, *kd, AB, *ldab, W, Z, *ldz, work, *lwork, rwork, info);
}

void chbevd_(char* jobz, char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    chbevd(jobz, uplo, *n, *kd, AB, *ldab, W, Z, *ldz, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
}

void chbevd_2stage_(char* jobz, char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    chbevd_2stage(jobz, uplo, *n, *kd, AB, *ldab, W, Z, *ldz, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
}

void chbevx_(char* jobz, char* range, char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, c64* Q, INT* ldq, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, c64* work, f32* rwork, INT* iwork, INT* ifail, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    chbevx(jobz, range, uplo, *n, *kd, AB, *ldab, Q, *ldq, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, work, rwork, iwork, ifail, info);
    if (ifail) { INT _sz = *m; for (INT _i = 0; _i < _sz; _i++) ifail[_i]++; }
}

void chbevx_2stage_(char* jobz, char* range, char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, c64* Q, INT* ldq, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* ifail, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    chbevx_2stage(jobz, range, uplo, *n, *kd, AB, *ldab, Q, *ldq, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, work, *lwork, rwork, iwork, ifail, info);
    if (*lwork != -1) {
        if (ifail) { INT _sz = *m; for (INT _i = 0; _i < _sz; _i++) ifail[_i]++; }
    }
}

void chbgst_(char* vect, char* uplo, INT* n, INT* ka, INT* kb, c64* AB, INT* ldab, c64* BB, INT* ldbb, c64* X, INT* ldx, c64* work, f32* rwork, INT* info) {
    chbgst(vect, uplo, *n, *ka, *kb, AB, *ldab, BB, *ldbb, X, *ldx, work, rwork, info);
}

void chbgv_(char* jobz, char* uplo, INT* n, INT* ka, INT* kb, c64* AB, INT* ldab, c64* BB, INT* ldbb, f32* W, c64* Z, INT* ldz, c64* work, f32* rwork, INT* info) {
    chbgv(jobz, uplo, *n, *ka, *kb, AB, *ldab, BB, *ldbb, W, Z, *ldz, work, rwork, info);
}

void chbgvd_(char* jobz, char* uplo, INT* n, INT* ka, INT* kb, c64* AB, INT* ldab, c64* BB, INT* ldbb, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    chbgvd(jobz, uplo, *n, *ka, *kb, AB, *ldab, BB, *ldbb, W, Z, *ldz, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
}

void chbgvx_(char* jobz, char* range, char* uplo, INT* n, INT* ka, INT* kb, c64* AB, INT* ldab, c64* BB, INT* ldbb, c64* Q, INT* ldq, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, c64* work, f32* rwork, INT* iwork, INT* ifail, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    chbgvx(jobz, range, uplo, *n, *ka, *kb, AB, *ldab, BB, *ldbb, Q, *ldq, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, work, rwork, iwork, ifail, info);
    if (ifail) { INT _sz = *m; for (INT _i = 0; _i < _sz; _i++) ifail[_i]++; }
}

void chbtrd_(char* vect, char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* D, f32* E, c64* Q, INT* ldq, c64* work, INT* info) {
    chbtrd(vect, uplo, *n, *kd, AB, *ldab, D, E, Q, *ldq, work, info);
}

void chfrk_(char* transr, char* uplo, char* trans, INT* n, INT* k, f32* alpha, c64* A, INT* lda, f32* beta, c64* C) {
    chfrk(transr, uplo, trans, *n, *k, *alpha, A, *lda, *beta, C);
}

void checon_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, f32* anorm, f32* rcond, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    checon(uplo, *n, A, *lda, _ipiv0, *anorm, rcond, work, info);
    free(_ipiv0);
}

void checon_3_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, f32* anorm, f32* rcond, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    checon_3(uplo, *n, A, *lda, E, _ipiv0, *anorm, rcond, work, info);
    free(_ipiv0);
}

void checon_rook_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, f32* anorm, f32* rcond, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    checon_rook(uplo, *n, A, *lda, _ipiv0, *anorm, rcond, work, info);
    free(_ipiv0);
}

void cheequb_(char* uplo, INT* n, c64* A, INT* lda, f32* S, f32* scond, f32* amax, c64* work, INT* info) {
    cheequb(uplo, *n, A, *lda, S, scond, amax, work, info);
}

void cheev_(char* jobz, char* uplo, INT* n, c64* A, INT* lda, f32* W, c64* work, INT* lwork, f32* rwork, INT* info) {
    cheev(jobz, uplo, *n, A, *lda, W, work, *lwork, rwork, info);
}

void cheev_2stage_(char* jobz, char* uplo, INT* n, c64* A, INT* lda, f32* W, c64* work, INT* lwork, f32* rwork, INT* info) {
    cheev_2stage(jobz, uplo, *n, A, *lda, W, work, *lwork, rwork, info);
}

void cheevd_(char* jobz, char* uplo, INT* n, c64* A, INT* lda, f32* W, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    cheevd(jobz, uplo, *n, A, *lda, W, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
}

void cheevd_2stage_(char* jobz, char* uplo, INT* n, c64* A, INT* lda, f32* W, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    cheevd_2stage(jobz, uplo, *n, A, *lda, W, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
}

void cheevr_(char* jobz, char* range, char* uplo, INT* n, c64* A, INT* lda, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, INT* isuppz, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    cheevr(jobz, range, uplo, *n, A, *lda, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, isuppz, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
    if (*lwork != -1) {
        if (isuppz && ((*jobz == 'V' || *jobz == 'v') && (*range == 'A' || *range == 'a'))) { INT _sz = 2 * (*m); for (INT _i = 0; _i < _sz; _i++) isuppz[_i]++; }
    }
}

void cheevr_2stage_(char* jobz, char* range, char* uplo, INT* n, c64* A, INT* lda, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, INT* isuppz, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    cheevr_2stage(jobz, range, uplo, *n, A, *lda, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, isuppz, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
    if (*lwork != -1) {
        if (isuppz && ((*jobz == 'V' || *jobz == 'v') && (*range == 'A' || *range == 'a'))) { INT _sz = 2 * (*m); for (INT _i = 0; _i < _sz; _i++) isuppz[_i]++; }
    }
}

void cheevx_(char* jobz, char* range, char* uplo, INT* n, c64* A, INT* lda, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* ifail, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    cheevx(jobz, range, uplo, *n, A, *lda, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, work, *lwork, rwork, iwork, ifail, info);
    if (*lwork != -1) {
        if (ifail) { INT _sz = *m; for (INT _i = 0; _i < _sz; _i++) ifail[_i]++; }
    }
}

void cheevx_2stage_(char* jobz, char* range, char* uplo, INT* n, c64* A, INT* lda, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* ifail, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    cheevx_2stage(jobz, range, uplo, *n, A, *lda, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, work, *lwork, rwork, iwork, ifail, info);
    if (*lwork != -1) {
        if (ifail) { INT _sz = *m; for (INT _i = 0; _i < _sz; _i++) ifail[_i]++; }
    }
}

void chegs2_(INT* itype, char* uplo, INT* n, c64* A, INT* lda, c64* B, INT* ldb, INT* info) {
    chegs2(*itype, uplo, *n, A, *lda, B, *ldb, info);
}

void chegst_(INT* itype, char* uplo, INT* n, c64* A, INT* lda, c64* B, INT* ldb, INT* info) {
    chegst(*itype, uplo, *n, A, *lda, B, *ldb, info);
}

void chegv_(INT* itype, char* jobz, char* uplo, INT* n, c64* A, INT* lda, c64* B, INT* ldb, f32* W, c64* work, INT* lwork, f32* rwork, INT* info) {
    chegv(*itype, jobz, uplo, *n, A, *lda, B, *ldb, W, work, *lwork, rwork, info);
}

void chegv_2stage_(INT* itype, char* jobz, char* uplo, INT* n, c64* A, INT* lda, c64* B, INT* ldb, f32* W, c64* work, INT* lwork, f32* rwork, INT* info) {
    chegv_2stage(*itype, jobz, uplo, *n, A, *lda, B, *ldb, W, work, *lwork, rwork, info);
}

void chegvd_(INT* itype, char* jobz, char* uplo, INT* n, c64* A, INT* lda, c64* B, INT* ldb, f32* W, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    chegvd(*itype, jobz, uplo, *n, A, *lda, B, *ldb, W, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
}

void chegvx_(INT* itype, char* jobz, char* range, char* uplo, INT* n, c64* A, INT* lda, c64* B, INT* ldb, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* iwork, INT* ifail, INT* info) {
    chegvx(*itype, jobz, range, uplo, *n, A, *lda, B, *ldb, *vl, *vu, *il, *iu, *abstol, m, W, Z, *ldz, work, *lwork, rwork, iwork, ifail, info);
}

void cherfs_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* AF, INT* ldaf, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cherfs(uplo, *n, *nrhs, A, *lda, AF, *ldaf, _ipiv0, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
    free(_ipiv0);
}

void chesv_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    chesv(uplo, *n, *nrhs, A, *lda, ipiv, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void chesv_aa_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    chesv_aa(uplo, *n, *nrhs, A, *lda, ipiv, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void chesv_aa_2stage_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* TB, INT* ltb, INT* ipiv, INT* ipiv2, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    chesv_aa_2stage(uplo, *n, *nrhs, A, *lda, TB, *ltb, ipiv, ipiv2, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
        if (ipiv2) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv2[_i] >= 0) ipiv2[_i]++; } }
    }
}

void chesv_rk_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* E, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    chesv_rk(uplo, *n, *nrhs, A, *lda, E, ipiv, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void chesv_rook_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    chesv_rook(uplo, *n, *nrhs, A, *lda, ipiv, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void chesvx_(char* fact, char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* AF, INT* ldaf, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, INT* lwork, f32* rwork, INT* info) {
    if (fact[0] == 'F' || fact[0] == 'f') {
        INT* _ipiv0 = NULL;
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
        chesvx(fact, uplo, *n, *nrhs, A, *lda, AF, *ldaf, _ipiv0, B, *ldb, X, *ldx, rcond, ferr, berr, work, *lwork, rwork, info);
        free(_ipiv0);
    } else {
        chesvx(fact, uplo, *n, *nrhs, A, *lda, AF, *ldaf, ipiv, B, *ldb, X, *ldx, rcond, ferr, berr, work, *lwork, rwork, info);
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void cheswapr_(char* uplo, INT* n, c64* A, INT* lda, INT* i1, INT* i2) {
    cheswapr(uplo, *n, A, *lda, *i1, *i2);
}

void chetd2_(char* uplo, INT* n, c64* A, INT* lda, f32* D, f32* E, c64* tau, INT* info) {
    chetd2(uplo, *n, A, *lda, D, E, tau, info);
}

void chetrd_(char* uplo, INT* n, c64* A, INT* lda, f32* D, f32* E, c64* tau, c64* work, INT* lwork, INT* info) {
    chetrd(uplo, *n, A, *lda, D, E, tau, work, *lwork, info);
}

void chetrd_2stage_(char* vect, char* uplo, INT* n, c64* A, INT* lda, f32* D, f32* E, c64* tau, c64* hous2, INT* lhous2, c64* work, INT* lwork, INT* info) {
    chetrd_2stage(vect, uplo, *n, A, *lda, D, E, tau, hous2, *lhous2, work, *lwork, info);
}

void chetrd_hb2st_(char* stage1, char* vect, char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* D, f32* E, c64* hous, INT* lhous, c64* work, INT* lwork, INT* info) {
    chetrd_hb2st(stage1, vect, uplo, *n, *kd, AB, *ldab, D, E, hous, *lhous, work, *lwork, info);
}

void chetrd_he2hb_(char* uplo, INT* n, INT* kd, c64* A, INT* lda, c64* AB, INT* ldab, c64* tau, c64* work, INT* lwork, INT* info) {
    chetrd_he2hb(uplo, *n, *kd, A, *lda, AB, *ldab, tau, work, *lwork, info);
}

void chetf2_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, INT* info) {
    chetf2(uplo, *n, A, *lda, ipiv, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void chetf2_rk_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, INT* info) {
    chetf2_rk(uplo, *n, A, *lda, E, ipiv, info);
}

void chetf2_rook_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, INT* info) {
    chetf2_rook(uplo, *n, A, *lda, ipiv, info);
}

void chetrf_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* lwork, INT* info) {
    chetrf(uplo, *n, A, *lda, ipiv, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void chetrf_aa_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* lwork, INT* info) {
    chetrf_aa(uplo, *n, A, *lda, ipiv, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void chetrf_aa_2stage_(char* uplo, INT* n, c64* A, INT* lda, c64* TB, INT* ltb, INT* ipiv, INT* ipiv2, c64* work, INT* lwork, INT* info) {
    chetrf_aa_2stage(uplo, *n, A, *lda, TB, *ltb, ipiv, ipiv2, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
        if (ipiv2) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv2[_i] >= 0) ipiv2[_i]++; } }
    }
}

void chetrf_rk_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, c64* work, INT* lwork, INT* info) {
    chetrf_rk(uplo, *n, A, *lda, E, ipiv, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void chetrf_rook_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* lwork, INT* info) {
    chetrf_rook(uplo, *n, A, *lda, ipiv, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void chetri_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chetri(uplo, *n, A, *lda, _ipiv0, work, info);
    free(_ipiv0);
}

void chetri2_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* lwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (*lwork != -1) {
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
    }
    if (*lwork != -1) {
        chetri2(uplo, *n, A, *lda, _ipiv0, work, *lwork, info);
    } else {
        chetri2(uplo, *n, A, *lda, ipiv, work, *lwork, info);
    }
    if (*lwork != -1) {
        free(_ipiv0);
    }
}

void chetri2x_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* nb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chetri2x(uplo, *n, A, *lda, _ipiv0, work, *nb, info);
    free(_ipiv0);
}

void chetri_rook_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chetri_rook(uplo, *n, A, *lda, _ipiv0, work, info);
    free(_ipiv0);
}

void chetri_3_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, c64* work, INT* lwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (*lwork != -1) {
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
    }
    if (*lwork != -1) {
        chetri_3(uplo, *n, A, *lda, E, _ipiv0, work, *lwork, info);
    } else {
        chetri_3(uplo, *n, A, *lda, E, ipiv, work, *lwork, info);
    }
    if (*lwork != -1) {
        free(_ipiv0);
    }
}

void chetri_3x_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, c64* work, INT* nb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chetri_3x(uplo, *n, A, *lda, E, _ipiv0, work, *nb, info);
    free(_ipiv0);
}

void chetrs_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chetrs(uplo, *n, *nrhs, A, *lda, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void chetrs2_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chetrs2(uplo, *n, *nrhs, A, *lda, _ipiv0, B, *ldb, work, info);
    free(_ipiv0);
}

void chetrs_3_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* E, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chetrs_3(uplo, *n, *nrhs, A, *lda, E, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void chetrs_aa_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (*lwork != -1) {
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
    }
    if (*lwork != -1) {
        chetrs_aa(uplo, *n, *nrhs, A, *lda, _ipiv0, B, *ldb, work, *lwork, info);
    } else {
        chetrs_aa(uplo, *n, *nrhs, A, *lda, ipiv, B, *ldb, work, *lwork, info);
    }
    if (*lwork != -1) {
        free(_ipiv0);
    }
}

void chetrs_aa_2stage_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* TB, INT* ltb, INT* ipiv, INT* ipiv2, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    INT* _ipiv20 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    if (ipiv2) {
        INT _ipiv2_sz = *n;
        _ipiv20 = (INT*)malloc(_ipiv2_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv2_sz; _i++) _ipiv20[_i] = (ipiv2[_i] > 0) ? ipiv2[_i] - 1 : ipiv2[_i];
    }
    chetrs_aa_2stage(uplo, *n, *nrhs, A, *lda, TB, *ltb, _ipiv0, _ipiv20, B, *ldb, info);
    free(_ipiv0);
    free(_ipiv20);
}

void chetrs_rook_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chetrs_rook(uplo, *n, *nrhs, A, *lda, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void chgeqz_(char* job, char* compq, char* compz, INT* n, INT* ilo, INT* ihi, c64* H, INT* ldh, c64* T, INT* ldt, c64* alpha, c64* beta, c64* Q, INT* ldq, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    chgeqz(job, compq, compz, *n, _ilo, _ihi, H, *ldh, T, *ldt, alpha, beta, Q, *ldq, Z, *ldz, work, *lwork, rwork, info);
}

void chpcon_(char* uplo, INT* n, c64* AP, INT* ipiv, f32* anorm, f32* rcond, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chpcon(uplo, *n, AP, _ipiv0, *anorm, rcond, work, info);
    free(_ipiv0);
}

void chpev_(char* jobz, char* uplo, INT* n, c64* AP, f32* W, c64* Z, INT* ldz, c64* work, f32* rwork, INT* info) {
    chpev(jobz, uplo, *n, AP, W, Z, *ldz, work, rwork, info);
}

void chpevd_(char* jobz, char* uplo, INT* n, c64* AP, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    chpevd(jobz, uplo, *n, AP, W, Z, *ldz, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
}

void chpevx_(char* jobz, char* range, char* uplo, INT* n, c64* AP, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, c64* work, f32* rwork, INT* iwork, INT* ifail, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    chpevx(jobz, range, uplo, *n, AP, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, work, rwork, iwork, ifail, info);
    if (ifail) { INT _sz = *m; for (INT _i = 0; _i < _sz; _i++) ifail[_i]++; }
}

void chpgst_(INT* itype, char* uplo, INT* n, c64* AP, c64* BP, INT* info) {
    chpgst(*itype, uplo, *n, AP, BP, info);
}

void chpgv_(INT* itype, char* jobz, char* uplo, INT* n, c64* AP, c64* BP, f32* W, c64* Z, INT* ldz, c64* work, f32* rwork, INT* info) {
    chpgv(*itype, jobz, uplo, *n, AP, BP, W, Z, *ldz, work, rwork, info);
}

void chpgvd_(INT* itype, char* jobz, char* uplo, INT* n, c64* AP, c64* BP, f32* W, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    chpgvd(*itype, jobz, uplo, *n, AP, BP, W, Z, *ldz, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
}

void chpgvx_(INT* itype, char* jobz, char* range, char* uplo, INT* n, c64* AP, c64* BP, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, c64* work, f32* rwork, INT* iwork, INT* ifail, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    chpgvx(*itype, jobz, range, uplo, *n, AP, BP, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, work, rwork, iwork, ifail, info);
    if (ifail) { INT _sz = *m; for (INT _i = 0; _i < _sz; _i++) ifail[_i]++; }
}

void chprfs_(char* uplo, INT* n, INT* nrhs, c64* AP, c64* AFP, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chprfs(uplo, *n, *nrhs, AP, AFP, _ipiv0, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
    free(_ipiv0);
}

void chpsv_(char* uplo, INT* n, INT* nrhs, c64* AP, INT* ipiv, c64* B, INT* ldb, INT* info) {
    chpsv(uplo, *n, *nrhs, AP, ipiv, B, *ldb, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void chpsvx_(char* fact, char* uplo, INT* n, INT* nrhs, c64* AP, c64* AFP, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    if (fact[0] == 'F' || fact[0] == 'f') {
        INT* _ipiv0 = NULL;
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
        chpsvx(fact, uplo, *n, *nrhs, AP, AFP, _ipiv0, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        free(_ipiv0);
    } else {
        chpsvx(fact, uplo, *n, *nrhs, AP, AFP, ipiv, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void chptrd_(char* uplo, INT* n, c64* AP, f32* d, f32* e, c64* tau, INT* info) {
    chptrd(uplo, *n, AP, d, e, tau, info);
}

void chptrf_(char* uplo, INT* n, c64* AP, INT* ipiv, INT* info) {
    chptrf(uplo, *n, AP, ipiv, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void chptri_(char* uplo, INT* n, c64* AP, INT* ipiv, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chptri(uplo, *n, AP, _ipiv0, work, info);
    free(_ipiv0);
}

void chptrs_(char* uplo, INT* n, INT* nrhs, c64* AP, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    chptrs(uplo, *n, *nrhs, AP, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void chsein_(char* side, char* eigsrc, char* initv, INT* select, INT* n, c64* H, INT* ldh, c64* W, c64* VL, INT* ldvl, c64* VR, INT* ldvr, INT* mm, INT* m, c64* work, f32* rwork, INT* ifaill, INT* ifailr, INT* info) {
    chsein(side, eigsrc, initv, select, *n, H, *ldh, W, VL, *ldvl, VR, *ldvr, *mm, m, work, rwork, ifaill, ifailr, info);
    if (ifaill) { INT _sz = *mm; for (INT _i = 0; _i < _sz; _i++) ifaill[_i]++; }
    if (ifailr) { INT _sz = *mm; for (INT _i = 0; _i < _sz; _i++) ifailr[_i]++; }
}

void chseqr_(char* job, char* compz, INT* n, INT* ilo, INT* ihi, c64* H, INT* ldh, c64* W, c64* Z, INT* ldz, c64* work, INT* lwork, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    chseqr(job, compz, *n, _ilo, _ihi, H, *ldh, W, Z, *ldz, work, *lwork, info);
}

void cla_gbamv_(INT* trans, INT* m, INT* n, INT* kl, INT* ku, f32* alpha, c64* AB, INT* ldab, c64* X, INT* incx, f32* beta, f32* Y, INT* incy) {
    cla_gbamv(*trans, *m, *n, *kl, *ku, *alpha, AB, *ldab, X, *incx, *beta, Y, *incy);
}

void cla_geamv_(INT* trans, INT* m, INT* n, f32* alpha, c64* A, INT* lda, c64* X, INT* incx, f32* beta, f32* Y, INT* incy) {
    cla_geamv(*trans, *m, *n, *alpha, A, *lda, X, *incx, *beta, Y, *incy);
}

void cla_lin_berr_(INT* n, INT* nz, INT* nrhs, c64* RES, f32* AYB, f32* BERR) {
    cla_lin_berr(*n, *nz, *nrhs, RES, AYB, BERR);
}

void clabrd_(INT* m, INT* n, INT* nb, c64* A, INT* lda, f32* D, f32* E, c64* tauq, c64* taup, c64* X, INT* ldx, c64* Y, INT* ldy) {
    clabrd(*m, *n, *nb, A, *lda, D, E, tauq, taup, X, *ldx, Y, *ldy);
}

void clacgv_(INT* n, c64* X, INT* incx) {
    clacgv(*n, X, *incx);
}

void clacn2_(INT* n, c64* V, c64* X, f32* est, INT* kase, INT* isave) {
    clacn2(*n, V, X, est, kase, isave);
}

void clacon_(INT* n, c64* V, c64* X, f32* est, INT* kase) {
    clacon(*n, V, X, est, kase);
}

void clacp2_(char* uplo, INT* m, INT* n, f32* A, INT* lda, c64* B, INT* ldb) {
    clacp2(uplo, *m, *n, A, *lda, B, *ldb);
}

void clacpy_(char* uplo, INT* m, INT* n, c64* A, INT* lda, c64* B, INT* ldb) {
    clacpy(uplo, *m, *n, A, *lda, B, *ldb);
}

void clacrm_(INT* m, INT* n, c64* A, INT* lda, f32* B, INT* ldb, c64* C, INT* ldc, f32* rwork) {
    clacrm(*m, *n, A, *lda, B, *ldb, C, *ldc, rwork);
}

void clacrt_(INT* n, c64* cx, INT* incx, c64* cy, INT* incy, c64* c, c64* s) {
    clacrt(*n, cx, *incx, cy, *incy, *c, *s);
}

void claed0_(INT* qsiz, INT* n, f32* D, f32* E, c64* Q, INT* ldq, c64* qstore, INT* ldqs, f32* rwork, INT* iwork, INT* info) {
    claed0(*qsiz, *n, D, E, Q, *ldq, qstore, *ldqs, rwork, iwork, info);
}

void claed7_(INT* n, INT* cutpnt, INT* qsiz, INT* tlvls, INT* curlvl, INT* curpbm, f32* D, c64* Q, INT* ldq, f32* rho, INT* indxq, f32* qstore, INT* qptr, INT* prmptr, INT* perm, INT* givptr, INT* givcol, f32* givnum, c64* work, f32* rwork, INT* iwork, INT* info) {
    claed7(*n, *cutpnt, *qsiz, *tlvls, *curlvl, *curpbm, D, Q, *ldq, *rho, indxq, qstore, qptr, prmptr, perm, givptr, givcol, givnum, work, rwork, iwork, info);
}

void claed8_(INT* K, INT* n, INT* qsiz, c64* Q, INT* ldq, f32* D, f32* rho, INT* cutpnt, f32* Z, f32* dlambda, c64* Q2, INT* ldq2, f32* W, INT* indxp, INT* indx, INT* indxq, INT* perm, INT* givptr, INT* givcol, f32* givnum, INT* info) {
    claed8(K, *n, *qsiz, Q, *ldq, D, rho, *cutpnt, Z, dlambda, Q2, *ldq2, W, indxp, indx, indxq, perm, givptr, givcol, givnum, info);
}

void claein_(INT* rightv, INT* noinit, INT* n, c64* H, INT* ldh, c64* w, c64* V, c64* B, INT* ldb, f32* rwork, f32* eps3, f32* smlnum, INT* info) {
    claein(*rightv, *noinit, *n, H, *ldh, *w, V, B, *ldb, rwork, *eps3, *smlnum, info);
}

void claesy_(c64* a, c64* b, c64* c, c64* rt1, c64* rt2, c64* evscal, c64* cs1, c64* sn1) {
    claesy(*a, *b, *c, rt1, rt2, evscal, cs1, sn1);
}

void claev2_(c64* a, c64* b, c64* c, f32* rt1, f32* rt2, f32* cs1, c64* sn1) {
    claev2(*a, *b, *c, rt1, rt2, cs1, sn1);
}

void clag2z_(INT* m, INT* n, c64* SA, INT* ldsa, c128* A, INT* lda, INT* info) {
    clag2z(*m, *n, SA, *ldsa, A, *lda, info);
}

void clags2_(INT* upper, f32* a1, c64* a2, f32* a3, f32* b1, c64* b2, f32* b3, f32* csu, c64* snu, f32* csv, c64* snv, f32* csq, c64* snq) {
    clags2(*upper, *a1, *a2, *a3, *b1, *b2, *b3, csu, snu, csv, snv, csq, snq);
}

void clagtm_(char* trans, INT* n, INT* nrhs, f32* alpha, c64* DL, c64* D, c64* DU, c64* X, INT* ldx, f32* beta, c64* B, INT* ldb) {
    clagtm(trans, *n, *nrhs, *alpha, DL, D, DU, X, *ldx, *beta, B, *ldb);
}

void clals0_(INT* icompq, INT* nl, INT* nr, INT* sqre, INT* nrhs, c64* B, INT* ldb, c64* BX, INT* ldbx, INT* perm, INT* givptr, INT* givcol, INT* ldgcol, f32* givnum, INT* ldgnum, f32* poles, f32* difl, f32* difr, f32* Z, INT* k, f32* c, f32* s, f32* rwork, INT* info) {
    clals0(*icompq, *nl, *nr, *sqre, *nrhs, B, *ldb, BX, *ldbx, perm, *givptr, givcol, *ldgcol, givnum, *ldgnum, poles, difl, difr, Z, *k, *c, *s, rwork, info);
}

void clalsa_(INT* icompq, INT* smlsiz, INT* n, INT* nrhs, c64* B, INT* ldb, c64* BX, INT* ldbx, f32* U, INT* ldu, f32* VT, INT* K, f32* difl, f32* difr, f32* Z, f32* poles, INT* givptr, INT* givcol, INT* ldgcol, INT* perm, f32* givnum, f32* C, f32* S, f32* rwork, INT* iwork, INT* info) {
    clalsa(*icompq, *smlsiz, *n, *nrhs, B, *ldb, BX, *ldbx, U, *ldu, VT, K, difl, difr, Z, poles, givptr, givcol, *ldgcol, perm, givnum, C, S, rwork, iwork, info);
}

void clalsd_(char* uplo, INT* smlsiz, INT* n, INT* nrhs, f32* D, f32* E, c64* B, INT* ldb, f32* rcond, INT* rank, c64* work, f32* rwork, INT* iwork, INT* info) {
    clalsd(uplo, *smlsiz, *n, *nrhs, D, E, B, *ldb, *rcond, rank, work, rwork, iwork, info);
}

void clahr2_(INT* n, INT* k, INT* nb, c64* A, INT* lda, c64* tau, c64* T, INT* ldt, c64* Y, INT* ldy) {
    clahr2(*n, *k, *nb, A, *lda, tau, T, *ldt, Y, *ldy);
}

void clahqr_(INT* wantt, INT* wantz, INT* n, INT* ilo, INT* ihi, c64* H, INT* ldh, c64* W, INT* iloz, INT* ihiz, c64* Z, INT* ldz, INT* info) {
    clahqr(*wantt, *wantz, *n, *ilo, *ihi, H, *ldh, W, *iloz, *ihiz, Z, *ldz, info);
}

void claic1_(INT* job, INT* j, c64* x, f32* sest, c64* w, c64* gamma_, f32* sestpr, c64* s, c64* c) {
    claic1(*job, *j, x, *sest, w, *gamma_, sestpr, s, c);
}

void clamswlq_(char* side, char* trans, INT* m, INT* n, INT* k, INT* mb, INT* nb, c64* A, INT* lda, c64* T, INT* ldt, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    clamswlq(side, trans, *m, *n, *k, *mb, *nb, A, *lda, T, *ldt, C, *ldc, work, *lwork, info);
}

void clamtsqr_(char* side, char* trans, INT* m, INT* n, INT* k, INT* mb, INT* nb, c64* A, INT* lda, c64* T, INT* ldt, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    clamtsqr(side, trans, *m, *n, *k, *mb, *nb, A, *lda, T, *ldt, C, *ldc, work, *lwork, info);
}

void clapll_(INT* n, c64* x, INT* incx, c64* y, INT* incy, f32* ssmin) {
    clapll(*n, x, *incx, y, *incy, ssmin);
}

void clapmr_(INT* forwrd, INT* m, INT* n, c64* X, INT* ldx, INT* K) {
    clapmr(*forwrd, *m, *n, X, *ldx, K);
}

void clapmt_(INT* forwrd, INT* m, INT* n, c64* X, INT* ldx, INT* K) {
    clapmt(*forwrd, *m, *n, X, *ldx, K);
}

void claqgb_(INT* m, INT* n, INT* kl, INT* ku, c64* AB, INT* ldab, f32* R, f32* C, f32* rowcnd, f32* colcnd, f32* amax, char* equed) {
    claqgb(*m, *n, *kl, *ku, AB, *ldab, R, C, *rowcnd, *colcnd, *amax, equed);
}

void claqge_(INT* m, INT* n, c64* A, INT* lda, f32* R, f32* C, f32* rowcnd, f32* colcnd, f32* amax, char* equed) {
    claqge(*m, *n, A, *lda, R, C, *rowcnd, *colcnd, *amax, equed);
}

void claqhb_(char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* S, f32* scond, f32* amax, char* equed) {
    claqhb(uplo, *n, *kd, AB, *ldab, S, *scond, *amax, equed);
}

void claqhe_(char* uplo, INT* n, c64* A, INT* lda, f32* S, f32* scond, f32* amax, char* equed) {
    claqhe(uplo, *n, A, *lda, S, *scond, *amax, equed);
}

void claqhp_(char* uplo, INT* n, c64* AP, f32* S, f32* scond, f32* amax, char* equed) {
    claqhp(uplo, *n, AP, S, *scond, *amax, equed);
}

void claqp2_(INT* m, INT* n, INT* offset, c64* A, INT* lda, INT* jpvt, c64* tau, f32* vn1, f32* vn2, c64* work) {
    claqp2(*m, *n, *offset, A, *lda, jpvt, tau, vn1, vn2, work);
    if (jpvt) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (jpvt[_i] >= 0) jpvt[_i]++; } }
}

void claqp2rk_(INT* m, INT* n, INT* nrhs, INT* ioffset, INT* kmax, f32* abstol, f32* reltol, INT* kp1, f32* maxc2nrm, c64* A, INT* lda, INT* K, f32* maxc2nrmk, f32* relmaxc2nrmk, INT* jpiv, c64* tau, f32* vn1, f32* vn2, c64* work, INT* info) {
    claqp2rk(*m, *n, *nrhs, *ioffset, *kmax, *abstol, *reltol, *kp1, *maxc2nrm, A, *lda, K, maxc2nrmk, relmaxc2nrmk, jpiv, tau, vn1, vn2, work, info);
}

void claqp3rk_(INT* m, INT* n, INT* nrhs, INT* ioffset, INT* nb, f32* abstol, f32* reltol, INT* kp1, f32* maxc2nrm, c64* A, INT* lda, INT* done, INT* KB, f32* maxc2nrmk, f32* relmaxc2nrmk, INT* jpiv, c64* tau, f32* vn1, f32* vn2, c64* auxv, c64* F, INT* ldf, INT* iwork, INT* info) {
    claqp3rk(*m, *n, *nrhs, *ioffset, nb, *abstol, *reltol, *kp1, *maxc2nrm, A, *lda, done, KB, maxc2nrmk, relmaxc2nrmk, jpiv, tau, vn1, vn2, auxv, F, *ldf, iwork, info);
}

void claqps_(INT* m, INT* n, INT* offset, INT* nb, INT* kb, c64* A, INT* lda, INT* jpvt, c64* tau, f32* vn1, f32* vn2, c64* auxv, c64* F, INT* ldf) {
    claqps(*m, *n, *offset, *nb, kb, A, *lda, jpvt, tau, vn1, vn2, auxv, F, *ldf);
    if (jpvt) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (jpvt[_i] >= 0) jpvt[_i]++; } }
}

void claqr0_(INT* wantt, INT* wantz, INT* n, INT* ilo, INT* ihi, c64* H, INT* ldh, c64* W, INT* iloz, INT* ihiz, c64* Z, INT* ldz, c64* work, INT* lwork, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    claqr0(*wantt, *wantz, *n, _ilo, _ihi, H, *ldh, W, *iloz, *ihiz, Z, *ldz, work, *lwork, info);
}

void claqr1_(INT* n, c64* H, INT* ldh, c64* s1, c64* s2, c64* v) {
    claqr1(*n, H, *ldh, *s1, *s2, v);
}

void claqr2_(INT* wantt, INT* wantz, INT* n, INT* ktop, INT* kbot, INT* nw, c64* H, INT* ldh, INT* iloz, INT* ihiz, c64* Z, INT* ldz, INT* ns, INT* nd, c64* SH, c64* V, INT* ldv, INT* nh, c64* T, INT* ldt, INT* nv, c64* WV, INT* ldwv, c64* work, INT* lwork) {
    claqr2(*wantt, *wantz, *n, *ktop, *kbot, *nw, H, *ldh, *iloz, *ihiz, Z, *ldz, ns, nd, SH, V, *ldv, *nh, T, *ldt, *nv, WV, *ldwv, work, *lwork);
}

void claqr3_(INT* wantt, INT* wantz, INT* n, INT* ktop, INT* kbot, INT* nw, c64* H, INT* ldh, INT* iloz, INT* ihiz, c64* Z, INT* ldz, INT* ns, INT* nd, c64* SH, c64* V, INT* ldv, INT* nh, c64* T, INT* ldt, INT* nv, c64* WV, INT* ldwv, c64* work, INT* lwork) {
    claqr3(*wantt, *wantz, *n, *ktop, *kbot, *nw, H, *ldh, *iloz, *ihiz, Z, *ldz, ns, nd, SH, V, *ldv, *nh, T, *ldt, *nv, WV, *ldwv, work, *lwork);
}

void claqr4_(INT* wantt, INT* wantz, INT* n, INT* ilo, INT* ihi, c64* H, INT* ldh, c64* W, INT* iloz, INT* ihiz, c64* Z, INT* ldz, c64* work, INT* lwork, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    claqr4(*wantt, *wantz, *n, _ilo, _ihi, H, *ldh, W, *iloz, *ihiz, Z, *ldz, work, *lwork, info);
}

void claqr5_(INT* wantt, INT* wantz, INT* kacc22, INT* n, INT* ktop, INT* kbot, INT* nshfts, c64* S, c64* H, INT* ldh, INT* iloz, INT* ihiz, c64* Z, INT* ldz, c64* V, INT* ldv, c64* U, INT* ldu, INT* nv, c64* WV, INT* ldwv, INT* nh, c64* WH, INT* ldwh) {
    claqr5(*wantt, *wantz, *kacc22, *n, *ktop, *kbot, *nshfts, S, H, *ldh, *iloz, *ihiz, Z, *ldz, V, *ldv, U, *ldu, *nv, WV, *ldwv, *nh, WH, *ldwh);
}

void claqsb_(char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* S, f32* scond, f32* amax, char* equed) {
    claqsb(uplo, *n, *kd, AB, *ldab, S, *scond, *amax, equed);
}

void claqsp_(char* uplo, INT* n, c64* AP, f32* S, f32* scond, f32* amax, char* equed) {
    claqsp(uplo, *n, AP, S, *scond, *amax, equed);
}

void claqsy_(char* uplo, INT* n, c64* A, INT* lda, f32* S, f32* scond, f32* amax, char* equed) {
    claqsy(uplo, *n, A, *lda, S, *scond, *amax, equed);
}

void claqz0_(char* wants, char* wantq, char* wantz, INT* n, INT* ilo, INT* ihi, c64* A, INT* lda, c64* B, INT* ldb, c64* alpha, c64* beta, c64* Q, INT* ldq, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* rec, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    claqz0(wants, wantq, wantz, *n, _ilo, _ihi, A, *lda, B, *ldb, alpha, beta, Q, *ldq, Z, *ldz, work, *lwork, rwork, *rec, info);
}

void claqz1_(INT* ilq, INT* ilz, INT* k, INT* istartm, INT* istopm, INT* ihi, c64* A, INT* lda, c64* B, INT* ldb, INT* nq, INT* qstart, c64* Q, INT* ldq, INT* nz, INT* zstart, c64* Z, INT* ldz) {
    claqz1(*ilq, *ilz, *k, *istartm, *istopm, *ihi, A, *lda, B, *ldb, *nq, *qstart, Q, *ldq, *nz, *zstart, Z, *ldz);
}

void claqz2_(INT* ilschur, INT* ilq, INT* ilz, INT* n, INT* ilo, INT* ihi, INT* nw, c64* A, INT* lda, c64* B, INT* ldb, c64* Q, INT* ldq, c64* Z, INT* ldz, INT* ns, INT* nd, c64* alpha, c64* beta, c64* QC, INT* ldqc, c64* ZC, INT* ldzc, c64* work, INT* lwork, f32* rwork, INT* rec, INT* info) {
    claqz2(*ilschur, *ilq, *ilz, *n, *ilo, *ihi, *nw, A, *lda, B, *ldb, Q, *ldq, Z, *ldz, ns, nd, alpha, beta, QC, *ldqc, ZC, *ldzc, work, *lwork, rwork, *rec, info);
}

void claqz3_(INT* ilschur, INT* ilq, INT* ilz, INT* n, INT* ilo, INT* ihi, INT* nshifts, INT* nblock_desired, c64* alpha, c64* beta, c64* A, INT* lda, c64* B, INT* ldb, c64* Q, INT* ldq, c64* Z, INT* ldz, c64* QC, INT* ldqc, c64* ZC, INT* ldzc, c64* work, INT* lwork, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    claqz3(*ilschur, *ilq, *ilz, *n, _ilo, _ihi, *nshifts, *nblock_desired, alpha, beta, A, *lda, B, *ldb, Q, *ldq, Z, *ldz, QC, *ldqc, ZC, *ldzc, work, *lwork, info);
}

void clar1v_(INT* n, INT* b1, INT* bn, f32* lambda, f32* D, f32* L, f32* LD, f32* LLD, f32* pivmin, f32* gaptol, c64* Z, INT* wantnc, INT* negcnt, f32* ztz, f32* mingma, INT* r, INT* isuppz, f32* nrminv, f32* resid, f32* rqcorr, f32* work) {
    clar1v(*n, *b1, *bn, *lambda, D, L, LD, LLD, *pivmin, *gaptol, Z, *wantnc, negcnt, ztz, mingma, r, isuppz, nrminv, resid, rqcorr, work);
}

void clar2v_(INT* n, c64* X, c64* Y, c64* Z, INT* incx, f32* C, c64* S, INT* incc) {
    clar2v(*n, X, Y, Z, *incx, C, S, *incc);
}

void clarcm_(INT* m, INT* n, f32* A, INT* lda, c64* B, INT* ldb, c64* C, INT* ldc, f32* rwork) {
    clarcm(*m, *n, A, *lda, B, *ldb, C, *ldc, rwork);
}

void clarf_(char* side, INT* m, INT* n, c64* v, INT* incv, c64* tau, c64* C, INT* ldc, c64* work) {
    clarf(side, *m, *n, v, *incv, *tau, C, *ldc, work);
}

void clarf1f_(char* side, INT* m, INT* n, c64* v, INT* incv, c64* tau, c64* C, INT* ldc, c64* work) {
    clarf1f(side, *m, *n, v, *incv, *tau, C, *ldc, work);
}

void clarf1l_(char* side, INT* m, INT* n, c64* v, INT* incv, c64* tau, c64* C, INT* ldc, c64* work) {
    clarf1l(side, *m, *n, v, *incv, *tau, C, *ldc, work);
}

void clarfb_(char* side, char* trans, char* direct, char* storev, INT* m, INT* n, INT* k, c64* V, INT* ldv, c64* T, INT* ldt, c64* C, INT* ldc, c64* work, INT* ldwork) {
    clarfb(side, trans, direct, storev, *m, *n, *k, V, *ldv, T, *ldt, C, *ldc, work, *ldwork);
}

void clarfb_gett_(char* ident, INT* m, INT* n, INT* k, c64* T, INT* ldt, c64* A, INT* lda, c64* B, INT* ldb, c64* work, INT* ldwork) {
    clarfb_gett(ident, *m, *n, *k, T, *ldt, A, *lda, B, *ldb, work, *ldwork);
}

void clarfg_(INT* n, c64* alpha, c64* x, INT* incx, c64* tau) {
    clarfg(*n, alpha, x, *incx, tau);
}

void clarfgp_(INT* n, c64* alpha, c64* x, INT* incx, c64* tau) {
    clarfgp(*n, alpha, x, *incx, tau);
}

void clarft_(char* direct, char* storev, INT* n, INT* k, c64* V, INT* ldv, c64* tau, c64* T, INT* ldt) {
    clarft(direct, storev, *n, *k, V, *ldv, tau, T, *ldt);
}

void clarft_lvl2_(char* direct, char* storev, INT* n, INT* k, c64* V, INT* ldv, c64* tau, c64* T, INT* ldt) {
    clarft_lvl2(direct, storev, *n, *k, V, *ldv, tau, T, *ldt);
}

void clarfx_(char* side, INT* m, INT* n, c64* v, c64* tau, c64* C, INT* ldc, c64* work) {
    clarfx(side, *m, *n, v, *tau, C, *ldc, work);
}

void clarfy_(char* uplo, INT* n, c64* V, INT* incv, c64* tau, c64* C, INT* ldc, c64* work) {
    clarfy(uplo, *n, V, *incv, *tau, C, *ldc, work);
}

void clargv_(INT* n, c64* X, INT* incx, c64* Y, INT* incy, f32* C, INT* incc) {
    clargv(*n, X, *incx, Y, *incy, C, *incc);
}

void clarnv_(INT* idist, INT* iseed, INT* n, c64* X) {
    clarnv(*idist, iseed, *n, X);
}

void clarrv_(INT* n, f32* vl, f32* vu, f32* D, f32* L, f32* pivmin, INT* isplit, INT* m, INT* dol, INT* dou, f32* minrgp, f32* rtol1, f32* rtol2, f32* W, f32* werr, f32* wgap, INT* iblock, INT* indexw, f32* gers, c64* Z, INT* ldz, INT* isuppz, f32* work, INT* iwork, INT* info) {
    INT* _isplit0 = NULL;
    INT* _iblock0 = NULL;
    INT* _indexw0 = NULL;
    if (isplit) {
        INT _isplit_sz = *n;
        _isplit0 = (INT*)malloc(_isplit_sz * sizeof(INT));
        for (INT _i = 0; _i < _isplit_sz; _i++) _isplit0[_i] = (isplit[_i] > 0) ? isplit[_i] - 1 : isplit[_i];
    }
    if (iblock) {
        INT _iblock_sz = *m;
        _iblock0 = (INT*)malloc(_iblock_sz * sizeof(INT));
        for (INT _i = 0; _i < _iblock_sz; _i++) _iblock0[_i] = (iblock[_i] > 0) ? iblock[_i] - 1 : iblock[_i];
    }
    if (indexw) {
        INT _indexw_sz = *m;
        _indexw0 = (INT*)malloc(_indexw_sz * sizeof(INT));
        for (INT _i = 0; _i < _indexw_sz; _i++) _indexw0[_i] = (indexw[_i] > 0) ? indexw[_i] - 1 : indexw[_i];
    }
    clarrv(*n, *vl, *vu, D, L, *pivmin, _isplit0, *m, *dol, *dou, *minrgp, *rtol1, *rtol2, W, werr, wgap, _iblock0, _indexw0, gers, Z, *ldz, isuppz, work, iwork, info);
    if (isuppz) { INT _sz = 2 * (*m); for (INT _i = 0; _i < _sz; _i++) isuppz[_i]++; }
    free(_isplit0);
    free(_iblock0);
    free(_indexw0);
}

void clarscl2_(INT* m, INT* n, f32* D, c64* X, INT* ldx) {
    clarscl2(*m, *n, D, X, *ldx);
}

void clartg_(c64* f, c64* g, f32* c, c64* s, c64* r) {
    clartg(*f, *g, c, s, r);
}

void clartv_(INT* n, c64* X, INT* incx, c64* Y, INT* incy, f32* C, c64* S, INT* incc) {
    clartv(*n, X, *incx, Y, *incy, C, S, *incc);
}

void clarz_(char* side, INT* m, INT* n, INT* l, c64* v, INT* incv, c64* tau, c64* C, INT* ldc, c64* work) {
    clarz(side, *m, *n, *l, v, *incv, *tau, C, *ldc, work);
}

void clarzb_(char* side, char* trans, char* direct, char* storev, INT* m, INT* n, INT* k, INT* l, c64* V, INT* ldv, c64* T, INT* ldt, c64* C, INT* ldc, c64* work, INT* ldwork) {
    clarzb(side, trans, direct, storev, *m, *n, *k, *l, V, *ldv, T, *ldt, C, *ldc, work, *ldwork);
}

void clarzt_(char* direct, char* storev, INT* n, INT* k, c64* V, INT* ldv, c64* tau, c64* T, INT* ldt) {
    clarzt(direct, storev, *n, *k, V, *ldv, tau, T, *ldt);
}

void clascl_(char* type, INT* kl, INT* ku, f32* cfrom, f32* cto, INT* m, INT* n, c64* A, INT* lda, INT* info) {
    clascl(type, *kl, *ku, *cfrom, *cto, *m, *n, A, *lda, info);
}

void clascl2_(INT* m, INT* n, f32* D, c64* X, INT* ldx) {
    clascl2(*m, *n, D, X, *ldx);
}

void claset_(char* uplo, INT* m, INT* n, c64* alpha, c64* beta, c64* A, INT* lda) {
    claset(uplo, *m, *n, *alpha, *beta, A, *lda);
}

void clasr_(char* side, char* pivot, char* direct, INT* m, INT* n, f32* C_rot, f32* S_rot, c64* A, INT* lda) {
    clasr(side, pivot, direct, *m, *n, C_rot, S_rot, A, *lda);
}

void classq_(INT* n, c64* X, INT* incx, f32* scale, f32* sumsq) {
    classq(*n, X, *incx, scale, sumsq);
}

void claswlq_(INT* m, INT* n, INT* mb, INT* nb, c64* A, INT* lda, c64* T, INT* ldt, c64* work, INT* lwork, INT* info) {
    claswlq(*m, *n, *mb, *nb, A, *lda, T, *ldt, work, *lwork, info);
}

void claswp_(INT* n, c64* A, INT* lda, INT* k1, INT* k2, INT* ipiv, INT* incx) {
    INT _k1 = *k1 - 1;
    INT _k2 = *k2 - 1;
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *k2;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    claswp(*n, A, *lda, _k1, _k2, _ipiv0, *incx);
    free(_ipiv0);
}

void clahef_(char* uplo, INT* n, INT* nb, INT* kb, c64* A, INT* lda, INT* ipiv, c64* W, INT* ldw, INT* info) {
    clahef(uplo, *n, *nb, kb, A, *lda, ipiv, W, *ldw, info);
}

void clahef_rk_(char* uplo, INT* n, INT* nb, INT* kb, c64* A, INT* lda, c64* E, INT* ipiv, c64* W, INT* ldw, INT* info) {
    clahef_rk(uplo, *n, *nb, kb, A, *lda, E, ipiv, W, *ldw, info);
}

void clahef_rook_(char* uplo, INT* n, INT* nb, INT* kb, c64* A, INT* lda, INT* ipiv, c64* W, INT* ldw, INT* info) {
    clahef_rook(uplo, *n, *nb, kb, A, *lda, ipiv, W, *ldw, info);
}

void clahef_aa_(char* uplo, INT* j1, INT* m, INT* nb, c64* A, INT* lda, INT* ipiv, c64* H, INT* ldh, c64* work) {
    clahef_aa(uplo, *j1, *m, *nb, A, *lda, ipiv, H, *ldh, work);
}

void clasyf_(char* uplo, INT* n, INT* nb, INT* kb, c64* A, INT* lda, INT* ipiv, c64* W, INT* ldw, INT* info) {
    clasyf(uplo, *n, *nb, kb, A, *lda, ipiv, W, *ldw, info);
}

void clasyf_aa_(char* uplo, INT* j1, INT* m, INT* nb, c64* A, INT* lda, INT* ipiv, c64* H, INT* ldh, c64* work) {
    clasyf_aa(uplo, *j1, *m, *nb, A, *lda, ipiv, H, *ldh, work);
}

void clasyf_rk_(char* uplo, INT* n, INT* nb, INT* kb, c64* A, INT* lda, c64* E, INT* ipiv, c64* W, INT* ldw, INT* info) {
    clasyf_rk(uplo, *n, *nb, kb, A, *lda, E, ipiv, W, *ldw, info);
}

void clasyf_rook_(char* uplo, INT* n, INT* nb, INT* kb, c64* A, INT* lda, INT* ipiv, c64* W, INT* ldw, INT* info) {
    clasyf_rook(uplo, *n, *nb, kb, A, *lda, ipiv, W, *ldw, info);
}

void clatbs_(char* uplo, char* trans, char* diag, char* normin, INT* n, INT* kd, c64* AB, INT* ldab, c64* X, f32* scale, f32* cnorm, INT* info) {
    clatbs(uplo, trans, diag, normin, *n, *kd, AB, *ldab, X, scale, cnorm, info);
}

void clatdf_(INT* ijob, INT* n, c64* Z, INT* ldz, c64* rhs, f32* rdsum, f32* rdscal, INT* ipiv, INT* jpiv) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    clatdf(*ijob, *n, Z, *ldz, rhs, rdsum, rdscal, _ipiv0, jpiv);
    free(_ipiv0);
}

void clatps_(char* uplo, char* trans, char* diag, char* normin, INT* n, c64* AP, c64* X, f32* scale, f32* cnorm, INT* info) {
    clatps(uplo, trans, diag, normin, *n, AP, X, scale, cnorm, info);
}

void clatrd_(char* uplo, INT* n, INT* nb, c64* A, INT* lda, f32* E, c64* tau, c64* W, INT* ldw) {
    clatrd(uplo, *n, *nb, A, *lda, E, tau, W, *ldw);
}

void clatrs_(char* uplo, char* trans, char* diag, char* normin, INT* n, c64* A, INT* lda, c64* X, f32* scale, f32* cnorm, INT* info) {
    clatrs(uplo, trans, diag, normin, *n, A, *lda, X, scale, cnorm, info);
}

void clatrs3_(char* uplo, char* trans, char* diag, char* normin, INT* n, INT* nrhs, c64* A, INT* lda, c64* X, INT* ldx, f32* scale, f32* cnorm, f32* work, INT* lwork, INT* info) {
    clatrs3(uplo, trans, diag, normin, *n, *nrhs, A, *lda, X, *ldx, scale, cnorm, work, *lwork, info);
}

void clatrz_(INT* m, INT* n, INT* l, c64* A, INT* lda, c64* tau, c64* work) {
    clatrz(*m, *n, *l, A, *lda, tau, work);
}

void clatsqr_(INT* m, INT* n, INT* mb, INT* nb, c64* A, INT* lda, c64* T, INT* ldt, c64* work, INT* lwork, INT* info) {
    clatsqr(*m, *n, *mb, *nb, A, *lda, T, *ldt, work, *lwork, info);
}

void claunhr_col_getrfnp_(INT* m, INT* n, c64* A, INT* lda, c64* D, INT* info) {
    claunhr_col_getrfnp(*m, *n, A, *lda, D, info);
}

void claunhr_col_getrfnp2_(INT* m, INT* n, c64* A, INT* lda, c64* D, INT* info) {
    claunhr_col_getrfnp2(*m, *n, A, *lda, D, info);
}

void clauu2_(char* uplo, INT* n, c64* A, INT* lda, INT* info) {
    clauu2(uplo, *n, A, *lda, info);
}

void clauum_(char* uplo, INT* n, c64* A, INT* lda, INT* info) {
    clauum(uplo, *n, A, *lda, info);
}

void cpbcon_(char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* anorm, f32* rcond, c64* work, f32* rwork, INT* info) {
    cpbcon(uplo, *n, *kd, AB, *ldab, *anorm, rcond, work, rwork, info);
}

void cpbequ_(char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, f32* S, f32* scond, f32* amax, INT* info) {
    cpbequ(uplo, *n, *kd, AB, *ldab, S, scond, amax, info);
}

void cpbrfs_(char* uplo, INT* n, INT* kd, INT* nrhs, c64* AB, INT* ldab, c64* AFB, INT* ldafb, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    cpbrfs(uplo, *n, *kd, *nrhs, AB, *ldab, AFB, *ldafb, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
}

void cpbstf_(char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, INT* info) {
    cpbstf(uplo, *n, *kd, AB, *ldab, info);
}

void cpbsv_(char* uplo, INT* n, INT* kd, INT* nrhs, c64* AB, INT* ldab, c64* B, INT* ldb, INT* info) {
    cpbsv(uplo, *n, *kd, *nrhs, AB, *ldab, B, *ldb, info);
}

void cpbsvx_(char* fact, char* uplo, INT* n, INT* kd, INT* nrhs, c64* AB, INT* ldab, c64* AFB, INT* ldafb, char* equed, f32* S, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    cpbsvx(fact, uplo, *n, *kd, *nrhs, AB, *ldab, AFB, *ldafb, equed, S, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
}

void cpbtf2_(char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, INT* info) {
    cpbtf2(uplo, *n, *kd, AB, *ldab, info);
}

void cpbtrf_(char* uplo, INT* n, INT* kd, c64* AB, INT* ldab, INT* info) {
    cpbtrf(uplo, *n, *kd, AB, *ldab, info);
}

void cpbtrs_(char* uplo, INT* n, INT* kd, INT* nrhs, c64* AB, INT* ldab, c64* B, INT* ldb, INT* info) {
    cpbtrs(uplo, *n, *kd, *nrhs, AB, *ldab, B, *ldb, info);
}

void cpftrf_(char* transr, char* uplo, INT* n, c64* A, INT* info) {
    cpftrf(transr, uplo, *n, A, info);
}

void cpftri_(char* transr, char* uplo, INT* n, c64* A, INT* info) {
    cpftri(transr, uplo, *n, A, info);
}

void cpftrs_(char* transr, char* uplo, INT* n, INT* nrhs, c64* A, c64* B, INT* ldb, INT* info) {
    cpftrs(transr, uplo, *n, *nrhs, A, B, *ldb, info);
}

void cpocon_(char* uplo, INT* n, c64* A, INT* lda, f32* anorm, f32* rcond, c64* work, f32* rwork, INT* info) {
    cpocon(uplo, *n, A, *lda, *anorm, rcond, work, rwork, info);
}

void cpoequ_(INT* n, c64* A, INT* lda, f32* S, f32* scond, f32* amax, INT* info) {
    cpoequ(*n, A, *lda, S, scond, amax, info);
}

void cpoequb_(INT* n, c64* A, INT* lda, f32* S, f32* scond, f32* amax, INT* info) {
    cpoequb(*n, A, *lda, S, scond, amax, info);
}

void cporfs_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* AF, INT* ldaf, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    cporfs(uplo, *n, *nrhs, A, *lda, AF, *ldaf, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
}

void cposv_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, INT* info) {
    cposv(uplo, *n, *nrhs, A, *lda, B, *ldb, info);
}

void cposvx_(char* fact, char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* AF, INT* ldaf, char* equed, f32* S, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    cposvx(fact, uplo, *n, *nrhs, A, *lda, AF, *ldaf, equed, S, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
}

void cpotf2_(char* uplo, INT* n, c64* A, INT* lda, INT* info) {
    cpotf2(uplo, *n, A, *lda, info);
}

void cpotrf_(char* uplo, INT* n, c64* A, INT* lda, INT* info) {
    cpotrf(uplo, *n, A, *lda, info);
}

void cpotrf2_(char* uplo, INT* n, c64* A, INT* lda, INT* info) {
    cpotrf2(uplo, *n, A, *lda, info);
}

void cpotri_(char* uplo, INT* n, c64* A, INT* lda, INT* info) {
    cpotri(uplo, *n, A, *lda, info);
}

void cpotrs_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, INT* info) {
    cpotrs(uplo, *n, *nrhs, A, *lda, B, *ldb, info);
}

void cppcon_(char* uplo, INT* n, c64* AP, f32* anorm, f32* rcond, c64* work, f32* rwork, INT* info) {
    cppcon(uplo, *n, AP, *anorm, rcond, work, rwork, info);
}

void cppequ_(char* uplo, INT* n, c64* AP, f32* S, f32* scond, f32* amax, INT* info) {
    cppequ(uplo, *n, AP, S, scond, amax, info);
}

void cpprfs_(char* uplo, INT* n, INT* nrhs, c64* AP, c64* AFP, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    cpprfs(uplo, *n, *nrhs, AP, AFP, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
}

void cppsv_(char* uplo, INT* n, INT* nrhs, c64* AP, c64* B, INT* ldb, INT* info) {
    cppsv(uplo, *n, *nrhs, AP, B, *ldb, info);
}

void cppsvx_(char* fact, char* uplo, INT* n, INT* nrhs, c64* AP, c64* AFP, char* equed, f32* S, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    cppsvx(fact, uplo, *n, *nrhs, AP, AFP, equed, S, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
}

void cpptrf_(char* uplo, INT* n, c64* AP, INT* info) {
    cpptrf(uplo, *n, AP, info);
}

void cpptri_(char* uplo, INT* n, c64* AP, INT* info) {
    cpptri(uplo, *n, AP, info);
}

void cpptrs_(char* uplo, INT* n, INT* nrhs, c64* AP, c64* B, INT* ldb, INT* info) {
    cpptrs(uplo, *n, *nrhs, AP, B, *ldb, info);
}

void cpstf2_(char* uplo, INT* n, c64* A, INT* lda, INT* piv, INT* rank, f32* tol, f32* work, INT* info) {
    cpstf2(uplo, *n, A, *lda, piv, rank, *tol, work, info);
    if (piv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (piv[_i] >= 0) piv[_i]++; } }
}

void cpstrf_(char* uplo, INT* n, c64* A, INT* lda, INT* piv, INT* rank, f32* tol, f32* work, INT* info) {
    cpstrf(uplo, *n, A, *lda, piv, rank, *tol, work, info);
    if (piv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (piv[_i] >= 0) piv[_i]++; } }
}

void cptcon_(INT* n, f32* D, c64* E, f32* anorm, f32* rcond, f32* rwork, INT* info) {
    cptcon(*n, D, E, *anorm, rcond, rwork, info);
}

void cpteqr_(char* compz, INT* n, f32* D, f32* E, c64* Z, INT* ldz, f32* work, INT* info) {
    cpteqr(compz, *n, D, E, Z, *ldz, work, info);
}

void cptrfs_(char* uplo, INT* n, INT* nrhs, f32* D, c64* E, f32* DF, c64* EF, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    cptrfs(uplo, *n, *nrhs, D, E, DF, EF, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
}

void cptsv_(INT* n, INT* nrhs, f32* D, c64* E, c64* B, INT* ldb, INT* info) {
    cptsv(*n, *nrhs, D, E, B, *ldb, info);
}

void cptsvx_(char* fact, INT* n, INT* nrhs, f32* D, c64* E, f32* DF, c64* EF, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    cptsvx(fact, *n, *nrhs, D, E, DF, EF, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
}

void cpttrf_(INT* n, f32* D, c64* E, INT* info) {
    cpttrf(*n, D, E, info);
}

void cpttrs_(char* uplo, INT* n, INT* nrhs, f32* D, c64* E, c64* B, INT* ldb, INT* info) {
    cpttrs(uplo, *n, *nrhs, D, E, B, *ldb, info);
}

void cptts2_(INT* iuplo, INT* n, INT* nrhs, f32* D, c64* E, c64* B, INT* ldb) {
    cptts2(*iuplo, *n, *nrhs, D, E, B, *ldb);
}

void crot_(INT* n, c64* CX, INT* incx, c64* CY, INT* incy, f32* c, c64* s) {
    crot(*n, CX, *incx, CY, *incy, *c, *s);
}

void crscl_(INT* n, c64* a, c64* x, INT* incx) {
    crscl(*n, *a, x, *incx);
}

void cspcon_(char* uplo, INT* n, c64* AP, INT* ipiv, f32* anorm, f32* rcond, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    cspcon(uplo, *n, AP, _ipiv0, *anorm, rcond, work, info);
    free(_ipiv0);
}

void cspmv_(char* uplo, INT* n, c64* alpha, c64* AP, c64* X, INT* incx, c64* beta, c64* Y, INT* incy) {
    cspmv(uplo, *n, *alpha, AP, X, *incx, *beta, Y, *incy);
}

void cspr_(char* uplo, INT* n, c64* alpha, c64* X, INT* incx, c64* AP) {
    cspr(uplo, *n, *alpha, X, *incx, AP);
}

void csprfs_(char* uplo, INT* n, INT* nrhs, c64* AP, c64* AFP, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csprfs(uplo, *n, *nrhs, AP, AFP, _ipiv0, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
    free(_ipiv0);
}

void cspsv_(char* uplo, INT* n, INT* nrhs, c64* AP, INT* ipiv, c64* B, INT* ldb, INT* info) {
    cspsv(uplo, *n, *nrhs, AP, ipiv, B, *ldb, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void cspsvx_(char* fact, char* uplo, INT* n, INT* nrhs, c64* AP, c64* AFP, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    if (fact[0] == 'F' || fact[0] == 'f') {
        INT* _ipiv0 = NULL;
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
        cspsvx(fact, uplo, *n, *nrhs, AP, AFP, _ipiv0, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        free(_ipiv0);
    } else {
        cspsvx(fact, uplo, *n, *nrhs, AP, AFP, ipiv, B, *ldb, X, *ldx, rcond, ferr, berr, work, rwork, info);
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csptrf_(char* uplo, INT* n, c64* AP, INT* ipiv, INT* info) {
    csptrf(uplo, *n, AP, ipiv, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void csptri_(char* uplo, INT* n, c64* AP, INT* ipiv, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csptri(uplo, *n, AP, _ipiv0, work, info);
    free(_ipiv0);
}

void csptrs_(char* uplo, INT* n, INT* nrhs, c64* AP, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csptrs(uplo, *n, *nrhs, AP, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void cstedc_(char* compz, INT* n, f32* D, f32* E, c64* Z, INT* ldz, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* liwork, INT* info) {
    cstedc(compz, *n, D, E, Z, *ldz, work, *lwork, rwork, *lrwork, iwork, *liwork, info);
}

void cstegr_(char* jobz, char* range, INT* n, f32* D, f32* E, f32* vl, f32* vu, INT* il, INT* iu, f32* abstol, INT* m, f32* W, c64* Z, INT* ldz, INT* isuppz, f32* work, INT* lwork, INT* iwork, INT* liwork, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    cstegr(jobz, range, *n, D, E, *vl, *vu, _il, _iu, *abstol, m, W, Z, *ldz, isuppz, work, *lwork, iwork, *liwork, info);
    if (*lwork != -1) {
        if (isuppz) { INT _sz = 2 * (*m); for (INT _i = 0; _i < _sz; _i++) isuppz[_i]++; }
    }
}

void cstein_(INT* n, f32* D, f32* E, INT* m, f32* W, INT* iblock, INT* isplit, c64* Z, INT* ldz, f32* work, INT* iwork, INT* ifail, INT* info) {
    INT* _iblock0 = NULL;
    INT* _isplit0 = NULL;
    if (iblock) {
        INT _iblock_sz = *m;
        _iblock0 = (INT*)malloc(_iblock_sz * sizeof(INT));
        for (INT _i = 0; _i < _iblock_sz; _i++) _iblock0[_i] = (iblock[_i] > 0) ? iblock[_i] - 1 : iblock[_i];
    }
    if (isplit) {
        INT _isplit_sz = *n;
        _isplit0 = (INT*)malloc(_isplit_sz * sizeof(INT));
        for (INT _i = 0; _i < _isplit_sz; _i++) _isplit0[_i] = (isplit[_i] > 0) ? isplit[_i] - 1 : isplit[_i];
    }
    cstein(*n, D, E, *m, W, _iblock0, _isplit0, Z, *ldz, work, iwork, ifail, info);
    if (ifail) { INT _sz = *m; for (INT _i = 0; _i < _sz; _i++) ifail[_i]++; }
    free(_iblock0);
    free(_isplit0);
}

void cstemr_(char* jobz, char* range, INT* n, f32* D, f32* E, f32* vl, f32* vu, INT* il, INT* iu, INT* m, f32* W, c64* Z, INT* ldz, INT* nzc, INT* isuppz, INT* tryrac, f32* work, INT* lwork, INT* iwork, INT* liwork, INT* info) {
    INT _il = *il - 1;
    INT _iu = *iu - 1;
    cstemr(jobz, range, *n, D, E, *vl, *vu, _il, _iu, m, W, Z, *ldz, *nzc, isuppz, tryrac, work, *lwork, iwork, *liwork, info);
    if (*lwork != -1) {
        if (isuppz) { INT _sz = 2 * (*m); for (INT _i = 0; _i < _sz; _i++) isuppz[_i]++; }
    }
}

void csteqr_(char* compz, INT* n, f32* D, f32* E, c64* Z, INT* ldz, f32* work, INT* info) {
    csteqr(compz, *n, D, E, Z, *ldz, work, info);
}

void csycon_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, f32* anorm, f32* rcond, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csycon(uplo, *n, A, *lda, _ipiv0, *anorm, rcond, work, info);
    free(_ipiv0);
}

void csycon_3_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, f32* anorm, f32* rcond, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csycon_3(uplo, *n, A, *lda, E, _ipiv0, *anorm, rcond, work, info);
    free(_ipiv0);
}

void csycon_rook_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, f32* anorm, f32* rcond, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csycon_rook(uplo, *n, A, *lda, _ipiv0, *anorm, rcond, work, info);
    free(_ipiv0);
}

void csyconv_(char* uplo, char* way, INT* n, c64* A, INT* lda, INT* ipiv, c64* E, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csyconv(uplo, way, *n, A, *lda, _ipiv0, E, info);
    free(_ipiv0);
}

void csyconvf_(char* uplo, char* way, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csyconvf(uplo, way, *n, A, *lda, E, _ipiv0, info);
    free(_ipiv0);
}

void csyconvf_rook_(char* uplo, char* way, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csyconvf_rook(uplo, way, *n, A, *lda, E, _ipiv0, info);
    free(_ipiv0);
}

void csyequb_(char* uplo, INT* n, c64* A, INT* lda, f32* S, f32* scond, f32* amax, c64* work, INT* info) {
    csyequb(uplo, *n, A, *lda, S, scond, amax, work, info);
}

void csymv_(char* uplo, INT* n, c64* alpha, c64* A, INT* lda, c64* X, INT* incx, c64* beta, c64* Y, INT* incy) {
    csymv(uplo, *n, *alpha, A, *lda, X, *incx, *beta, Y, *incy);
}

void csyr_(char* uplo, INT* n, c64* alpha, c64* X, INT* incx, c64* A, INT* lda) {
    csyr(uplo, *n, *alpha, X, *incx, A, *lda);
}

void csyrfs_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* AF, INT* ldaf, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csyrfs(uplo, *n, *nrhs, A, *lda, AF, *ldaf, _ipiv0, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
    free(_ipiv0);
}

void csysv_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    csysv(uplo, *n, *nrhs, A, *lda, ipiv, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csysv_aa_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    csysv_aa(uplo, *n, *nrhs, A, *lda, ipiv, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csysv_aa_2stage_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* TB, INT* ltb, INT* ipiv, INT* ipiv2, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    csysv_aa_2stage(uplo, *n, *nrhs, A, *lda, TB, *ltb, ipiv, ipiv2, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
        if (ipiv2) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv2[_i] >= 0) ipiv2[_i]++; } }
    }
}

void csysv_rk_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* E, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    csysv_rk(uplo, *n, *nrhs, A, *lda, E, ipiv, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csysv_rook_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    csysv_rook(uplo, *n, *nrhs, A, *lda, ipiv, B, *ldb, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csysvx_(char* fact, char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* AF, INT* ldaf, INT* ipiv, c64* B, INT* ldb, c64* X, INT* ldx, f32* rcond, f32* ferr, f32* berr, c64* work, INT* lwork, f32* rwork, INT* info) {
    if (fact[0] == 'F' || fact[0] == 'f') {
        INT* _ipiv0 = NULL;
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
        csysvx(fact, uplo, *n, *nrhs, A, *lda, AF, *ldaf, _ipiv0, B, *ldb, X, *ldx, rcond, ferr, berr, work, *lwork, rwork, info);
        free(_ipiv0);
    } else {
        csysvx(fact, uplo, *n, *nrhs, A, *lda, AF, *ldaf, ipiv, B, *ldb, X, *ldx, rcond, ferr, berr, work, *lwork, rwork, info);
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csyswapr_(char* uplo, INT* n, c64* A, INT* lda, INT* i1, INT* i2) {
    csyswapr(uplo, *n, A, *lda, *i1, *i2);
}

void csytf2_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, INT* info) {
    csytf2(uplo, *n, A, *lda, ipiv, info);
    if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
}

void csytf2_rk_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, INT* info) {
    csytf2_rk(uplo, *n, A, *lda, E, ipiv, info);
}

void csytf2_rook_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, INT* info) {
    csytf2_rook(uplo, *n, A, *lda, ipiv, info);
}

void csytrf_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* lwork, INT* info) {
    csytrf(uplo, *n, A, *lda, ipiv, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csytrf_aa_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* lwork, INT* info) {
    csytrf_aa(uplo, *n, A, *lda, ipiv, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csytrf_aa_2stage_(char* uplo, INT* n, c64* A, INT* lda, c64* TB, INT* ltb, INT* ipiv, INT* ipiv2, c64* work, INT* lwork, INT* info) {
    csytrf_aa_2stage(uplo, *n, A, *lda, TB, *ltb, ipiv, ipiv2, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
        if (ipiv2) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv2[_i] >= 0) ipiv2[_i]++; } }
    }
}

void csytrf_rk_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, c64* work, INT* lwork, INT* info) {
    csytrf_rk(uplo, *n, A, *lda, E, ipiv, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csytrf_rook_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* lwork, INT* info) {
    csytrf_rook(uplo, *n, A, *lda, ipiv, work, *lwork, info);
    if (*lwork != -1) {
        if (ipiv) { INT _sz = *n; for (INT _i = 0; _i < _sz; _i++) { if (ipiv[_i] >= 0) ipiv[_i]++; } }
    }
}

void csytri_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csytri(uplo, *n, A, *lda, _ipiv0, work, info);
    free(_ipiv0);
}

void csytri2_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* lwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (*lwork != -1) {
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
    }
    if (*lwork != -1) {
        csytri2(uplo, *n, A, *lda, _ipiv0, work, *lwork, info);
    } else {
        csytri2(uplo, *n, A, *lda, ipiv, work, *lwork, info);
    }
    if (*lwork != -1) {
        free(_ipiv0);
    }
}

void csytri2x_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* nb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csytri2x(uplo, *n, A, *lda, _ipiv0, work, *nb, info);
    free(_ipiv0);
}

void csytri_3_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, c64* work, INT* lwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (*lwork != -1) {
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
    }
    if (*lwork != -1) {
        csytri_3(uplo, *n, A, *lda, E, _ipiv0, work, *lwork, info);
    } else {
        csytri_3(uplo, *n, A, *lda, E, ipiv, work, *lwork, info);
    }
    if (*lwork != -1) {
        free(_ipiv0);
    }
}

void csytri_3x_(char* uplo, INT* n, c64* A, INT* lda, c64* E, INT* ipiv, c64* work, INT* nb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csytri_3x(uplo, *n, A, *lda, E, _ipiv0, work, *nb, info);
    free(_ipiv0);
}

void csytri_rook_(char* uplo, INT* n, c64* A, INT* lda, INT* ipiv, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csytri_rook(uplo, *n, A, *lda, _ipiv0, work, info);
    free(_ipiv0);
}

void csytrs_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csytrs(uplo, *n, *nrhs, A, *lda, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void csytrs2_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csytrs2(uplo, *n, *nrhs, A, *lda, _ipiv0, B, *ldb, work, info);
    free(_ipiv0);
}

void csytrs_3_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* E, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csytrs_3(uplo, *n, *nrhs, A, *lda, E, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void csytrs_aa_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, c64* work, INT* lwork, INT* info) {
    INT* _ipiv0 = NULL;
    if (*lwork != -1) {
        if (ipiv) {
            INT _ipiv_sz = *n;
            _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
            for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
        }
    }
    if (*lwork != -1) {
        csytrs_aa(uplo, *n, *nrhs, A, *lda, _ipiv0, B, *ldb, work, *lwork, info);
    } else {
        csytrs_aa(uplo, *n, *nrhs, A, *lda, ipiv, B, *ldb, work, *lwork, info);
    }
    if (*lwork != -1) {
        free(_ipiv0);
    }
}

void csytrs_aa_2stage_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, c64* TB, INT* ltb, INT* ipiv, INT* ipiv2, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    INT* _ipiv20 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    if (ipiv2) {
        INT _ipiv2_sz = *n;
        _ipiv20 = (INT*)malloc(_ipiv2_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv2_sz; _i++) _ipiv20[_i] = (ipiv2[_i] > 0) ? ipiv2[_i] - 1 : ipiv2[_i];
    }
    csytrs_aa_2stage(uplo, *n, *nrhs, A, *lda, TB, *ltb, _ipiv0, _ipiv20, B, *ldb, info);
    free(_ipiv0);
    free(_ipiv20);
}

void csytrs_rook_(char* uplo, INT* n, INT* nrhs, c64* A, INT* lda, INT* ipiv, c64* B, INT* ldb, INT* info) {
    INT* _ipiv0 = NULL;
    if (ipiv) {
        INT _ipiv_sz = *n;
        _ipiv0 = (INT*)malloc(_ipiv_sz * sizeof(INT));
        for (INT _i = 0; _i < _ipiv_sz; _i++) _ipiv0[_i] = (ipiv[_i] > 0) ? ipiv[_i] - 1 : ipiv[_i];
    }
    csytrs_rook(uplo, *n, *nrhs, A, *lda, _ipiv0, B, *ldb, info);
    free(_ipiv0);
}

void ctbcon_(char* norm, char* uplo, char* diag, INT* n, INT* kd, c64* AB, INT* ldab, f32* rcond, c64* work, f32* rwork, INT* info) {
    ctbcon(norm, uplo, diag, *n, *kd, AB, *ldab, rcond, work, rwork, info);
}

void ctbrfs_(char* uplo, char* trans, char* diag, INT* n, INT* kd, INT* nrhs, c64* AB, INT* ldab, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    ctbrfs(uplo, trans, diag, *n, *kd, *nrhs, AB, *ldab, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
}

void ctbtrs_(char* uplo, char* trans, char* diag, INT* n, INT* kd, INT* nrhs, c64* AB, INT* ldab, c64* B, INT* ldb, INT* info) {
    ctbtrs(uplo, trans, diag, *n, *kd, *nrhs, AB, *ldab, B, *ldb, info);
}

void ctfsm_(char* transr, char* side, char* uplo, char* trans, char* diag, INT* m, INT* n, c64* alpha, c64* A, c64* B, INT* ldb) {
    ctfsm(transr, side, uplo, trans, diag, *m, *n, *alpha, A, B, *ldb);
}

void ctftri_(char* transr, char* uplo, char* diag, INT* n, c64* A, INT* info) {
    ctftri(transr, uplo, diag, *n, A, info);
}

void ctfttp_(char* transr, char* uplo, INT* n, c64* ARF, c64* AP, INT* info) {
    ctfttp(transr, uplo, *n, ARF, AP, info);
}

void ctfttr_(char* transr, char* uplo, INT* n, c64* ARF, c64* A, INT* lda, INT* info) {
    ctfttr(transr, uplo, *n, ARF, A, *lda, info);
}

void ctgex2_(INT* wantq, INT* wantz, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* Q, INT* ldq, c64* Z, INT* ldz, INT* j1, INT* info) {
    ctgex2(*wantq, *wantz, *n, A, *lda, B, *ldb, Q, *ldq, Z, *ldz, *j1, info);
}

void ctgexc_(INT* wantq, INT* wantz, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* Q, INT* ldq, c64* Z, INT* ldz, INT* ifst, INT* ilst, INT* info) {
    INT _ifst = *ifst - 1;
    INT _ilst = *ilst - 1;
    ctgexc(*wantq, *wantz, *n, A, *lda, B, *ldb, Q, *ldq, Z, *ldz, _ifst, &_ilst, info);
    *ilst = _ilst + 1;
}

void ctgevc_(char* side, char* howmny, INT* select, INT* n, c64* S, INT* lds, c64* P, INT* ldp, c64* VL, INT* ldvl, c64* VR, INT* ldvr, INT* mm, INT* m, c64* work, f32* rwork, INT* info) {
    ctgevc(side, howmny, select, *n, S, *lds, P, *ldp, VL, *ldvl, VR, *ldvr, *mm, m, work, rwork, info);
}

void ctgsen_(INT* ijob, INT* wantq, INT* wantz, INT* select, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* alpha, c64* beta, c64* Q, INT* ldq, c64* Z, INT* ldz, INT* m, f32* pl, f32* pr, f32* dif, c64* work, INT* lwork, INT* iwork, INT* liwork, INT* info) {
    ctgsen(*ijob, *wantq, *wantz, select, *n, A, *lda, B, *ldb, alpha, beta, Q, *ldq, Z, *ldz, m, pl, pr, dif, work, *lwork, iwork, *liwork, info);
}

void ctgsna_(char* job, char* howmny, INT* select, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* VL, INT* ldvl, c64* VR, INT* ldvr, f32* S, f32* dif, INT* mm, INT* m, c64* work, INT* lwork, INT* iwork, INT* info) {
    ctgsna(job, howmny, select, *n, A, *lda, B, *ldb, VL, *ldvl, VR, *ldvr, S, dif, *mm, m, work, *lwork, iwork, info);
}

void ctgsyl_(char* trans, INT* ijob, INT* m, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* C, INT* ldc, c64* D, INT* ldd, c64* E, INT* lde, c64* F, INT* ldf, f32* scale, f32* dif, c64* work, INT* lwork, INT* iwork, INT* info) {
    ctgsyl(trans, *ijob, *m, *n, A, *lda, B, *ldb, C, *ldc, D, *ldd, E, *lde, F, *ldf, scale, dif, work, *lwork, iwork, info);
}

void ctgsja_(char* jobu, char* jobv, char* jobq, INT* m, INT* p, INT* n, INT* k, INT* l, c64* A, INT* lda, c64* B, INT* ldb, f32* tola, f32* tolb, f32* alpha, f32* beta, c64* U, INT* ldu, c64* V, INT* ldv, c64* Q, INT* ldq, c64* work, INT* ncycle, INT* info) {
    ctgsja(jobu, jobv, jobq, *m, *p, *n, *k, *l, A, *lda, B, *ldb, *tola, *tolb, alpha, beta, U, *ldu, V, *ldv, Q, *ldq, work, ncycle, info);
}

void ctgsy2_(char* trans, INT* ijob, INT* m, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* C, INT* ldc, c64* D, INT* ldd, c64* E, INT* lde, c64* F, INT* ldf, f32* scale, f32* rdsum, f32* rdscal, INT* info) {
    ctgsy2(trans, *ijob, *m, *n, A, *lda, B, *ldb, C, *ldc, D, *ldd, E, *lde, F, *ldf, scale, rdsum, rdscal, info);
}

void ctpcon_(char* norm, char* uplo, char* diag, INT* n, c64* AP, f32* rcond, c64* work, f32* rwork, INT* info) {
    ctpcon(norm, uplo, diag, *n, AP, rcond, work, rwork, info);
}

void ctplqt_(INT* m, INT* n, INT* l, INT* mb, c64* A, INT* lda, c64* B, INT* ldb, c64* T, INT* ldt, c64* work, INT* info) {
    ctplqt(*m, *n, *l, *mb, A, *lda, B, *ldb, T, *ldt, work, info);
}

void ctplqt2_(INT* m, INT* n, INT* l, c64* A, INT* lda, c64* B, INT* ldb, c64* T, INT* ldt, INT* info) {
    ctplqt2(*m, *n, *l, A, *lda, B, *ldb, T, *ldt, info);
}

void ctpmlqt_(char* side, char* trans, INT* m, INT* n, INT* k, INT* l, INT* mb, c64* V, INT* ldv, c64* T, INT* ldt, c64* A, INT* lda, c64* B, INT* ldb, c64* work, INT* info) {
    ctpmlqt(side, trans, *m, *n, *k, *l, *mb, V, *ldv, T, *ldt, A, *lda, B, *ldb, work, info);
}

void ctpmqrt_(char* side, char* trans, INT* m, INT* n, INT* k, INT* l, INT* nb, c64* V, INT* ldv, c64* T, INT* ldt, c64* A, INT* lda, c64* B, INT* ldb, c64* work, INT* info) {
    ctpmqrt(side, trans, *m, *n, *k, *l, *nb, V, *ldv, T, *ldt, A, *lda, B, *ldb, work, info);
}

void ctpqrt_(INT* m, INT* n, INT* l, INT* nb, c64* A, INT* lda, c64* B, INT* ldb, c64* T, INT* ldt, c64* work, INT* info) {
    ctpqrt(*m, *n, *l, *nb, A, *lda, B, *ldb, T, *ldt, work, info);
}

void ctpqrt2_(INT* m, INT* n, INT* l, c64* A, INT* lda, c64* B, INT* ldb, c64* T, INT* ldt, INT* info) {
    ctpqrt2(*m, *n, *l, A, *lda, B, *ldb, T, *ldt, info);
}

void ctprfb_(char* side, char* trans, char* direct, char* storev, INT* m, INT* n, INT* k, INT* l, c64* V, INT* ldv, c64* T, INT* ldt, c64* A, INT* lda, c64* B, INT* ldb, c64* work, INT* ldwork) {
    ctprfb(side, trans, direct, storev, *m, *n, *k, *l, V, *ldv, T, *ldt, A, *lda, B, *ldb, work, *ldwork);
}

void ctprfs_(char* uplo, char* trans, char* diag, INT* n, INT* nrhs, c64* AP, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    ctprfs(uplo, trans, diag, *n, *nrhs, AP, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
}

void ctptri_(char* uplo, char* diag, INT* n, c64* AP, INT* info) {
    ctptri(uplo, diag, *n, AP, info);
}

void ctptrs_(char* uplo, char* trans, char* diag, INT* n, INT* nrhs, c64* AP, c64* B, INT* ldb, INT* info) {
    ctptrs(uplo, trans, diag, *n, *nrhs, AP, B, *ldb, info);
}

void ctpttf_(char* transr, char* uplo, INT* n, c64* AP, c64* ARF, INT* info) {
    ctpttf(transr, uplo, *n, AP, ARF, info);
}

void ctpttr_(char* uplo, INT* n, c64* AP, c64* A, INT* lda, INT* info) {
    ctpttr(uplo, *n, AP, A, *lda, info);
}

void ctrcon_(char* norm, char* uplo, char* diag, INT* n, c64* A, INT* lda, f32* rcond, c64* work, f32* rwork, INT* info) {
    ctrcon(norm, uplo, diag, *n, A, *lda, rcond, work, rwork, info);
}

void ctrevc_(char* side, char* howmny, INT* select, INT* n, c64* T, INT* ldt, c64* VL, INT* ldvl, c64* VR, INT* ldvr, INT* mm, INT* m, c64* work, f32* rwork, INT* info) {
    ctrevc(side, howmny, select, *n, T, *ldt, VL, *ldvl, VR, *ldvr, *mm, m, work, rwork, info);
}

void ctrevc3_(char* side, char* howmny, INT* select, INT* n, c64* T, INT* ldt, c64* VL, INT* ldvl, c64* VR, INT* ldvr, INT* mm, INT* m, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* info) {
    ctrevc3(side, howmny, select, *n, T, *ldt, VL, *ldvl, VR, *ldvr, *mm, m, work, *lwork, rwork, *lrwork, info);
}

void ctrexc_(char* compq, INT* n, c64* T, INT* ldt, c64* Q, INT* ldq, INT* ifst, INT* ilst, INT* info) {
    INT _ifst = *ifst - 1;
    INT _ilst = *ilst - 1;
    ctrexc(compq, *n, T, *ldt, Q, *ldq, _ifst, _ilst, info);
}

void ctrrfs_(char* uplo, char* trans, char* diag, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, c64* X, INT* ldx, f32* ferr, f32* berr, c64* work, f32* rwork, INT* info) {
    ctrrfs(uplo, trans, diag, *n, *nrhs, A, *lda, B, *ldb, X, *ldx, ferr, berr, work, rwork, info);
}

void ctrsen_(char* job, char* compq, INT* select, INT* n, c64* T, INT* ldt, c64* Q, INT* ldq, c64* W, INT* m, f32* s, f32* sep, c64* work, INT* lwork, INT* info) {
    ctrsen(job, compq, select, *n, T, *ldt, Q, *ldq, W, m, s, sep, work, *lwork, info);
}

void ctrsna_(char* job, char* howmny, INT* select, INT* n, c64* T, INT* ldt, c64* VL, INT* ldvl, c64* VR, INT* ldvr, f32* S, f32* sep, INT* mm, INT* m, c64* work, INT* ldwork, f32* rwork, INT* info) {
    ctrsna(job, howmny, select, *n, T, *ldt, VL, *ldvl, VR, *ldvr, S, sep, *mm, m, work, *ldwork, rwork, info);
}

void ctrsyl_(char* trana, char* tranb, INT* isgn, INT* m, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* C, INT* ldc, f32* scale, INT* info) {
    ctrsyl(trana, tranb, *isgn, *m, *n, A, *lda, B, *ldb, C, *ldc, scale, info);
}

void ctrsyl3_(char* trana, char* tranb, INT* isgn, INT* m, INT* n, c64* A, INT* lda, c64* B, INT* ldb, c64* C, INT* ldc, f32* scale, f32* swork, INT* ldswork, INT* info) {
    ctrsyl3(trana, tranb, *isgn, *m, *n, A, *lda, B, *ldb, C, *ldc, scale, swork, *ldswork, info);
}

void ctrti2_(char* uplo, char* diag, INT* n, c64* A, INT* lda, INT* info) {
    ctrti2(uplo, diag, *n, A, *lda, info);
}

void ctrtri_(char* uplo, char* diag, INT* n, c64* A, INT* lda, INT* info) {
    ctrtri(uplo, diag, *n, A, *lda, info);
}

void ctrtrs_(char* uplo, char* trans, char* diag, INT* n, INT* nrhs, c64* A, INT* lda, c64* B, INT* ldb, INT* info) {
    ctrtrs(uplo, trans, diag, *n, *nrhs, A, *lda, B, *ldb, info);
}

void ctrttf_(char* transr, char* uplo, INT* n, c64* A, INT* lda, c64* ARF, INT* info) {
    ctrttf(transr, uplo, *n, A, *lda, ARF, info);
}

void ctrttp_(char* uplo, INT* n, c64* A, INT* lda, c64* AP, INT* info) {
    ctrttp(uplo, *n, A, *lda, AP, info);
}

void ctzrzf_(INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    ctzrzf(*m, *n, A, *lda, tau, work, *lwork, info);
}

void cunbdb_(char* trans, char* signs, INT* m, INT* p, INT* q, c64* X11, INT* ldx11, c64* X12, INT* ldx12, c64* X21, INT* ldx21, c64* X22, INT* ldx22, f32* theta, f32* phi, c64* taup1, c64* taup2, c64* tauq1, c64* tauq2, c64* work, INT* lwork, INT* info) {
    cunbdb(trans, signs, *m, *p, *q, X11, *ldx11, X12, *ldx12, X21, *ldx21, X22, *ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, *lwork, info);
}

void cunbdb1_(INT* m, INT* p, INT* q, c64* X11, INT* ldx11, c64* X21, INT* ldx21, f32* theta, f32* phi, c64* taup1, c64* taup2, c64* tauq1, c64* work, INT* lwork, INT* info) {
    cunbdb1(*m, *p, *q, X11, *ldx11, X21, *ldx21, theta, phi, taup1, taup2, tauq1, work, *lwork, info);
}

void cunbdb2_(INT* m, INT* p, INT* q, c64* X11, INT* ldx11, c64* X21, INT* ldx21, f32* theta, f32* phi, c64* taup1, c64* taup2, c64* tauq1, c64* work, INT* lwork, INT* info) {
    cunbdb2(*m, *p, *q, X11, *ldx11, X21, *ldx21, theta, phi, taup1, taup2, tauq1, work, *lwork, info);
}

void cunbdb3_(INT* m, INT* p, INT* q, c64* X11, INT* ldx11, c64* X21, INT* ldx21, f32* theta, f32* phi, c64* taup1, c64* taup2, c64* tauq1, c64* work, INT* lwork, INT* info) {
    cunbdb3(*m, *p, *q, X11, *ldx11, X21, *ldx21, theta, phi, taup1, taup2, tauq1, work, *lwork, info);
}

void cunbdb4_(INT* m, INT* p, INT* q, c64* X11, INT* ldx11, c64* X21, INT* ldx21, f32* theta, f32* phi, c64* taup1, c64* taup2, c64* tauq1, c64* phantom, c64* work, INT* lwork, INT* info) {
    cunbdb4(*m, *p, *q, X11, *ldx11, X21, *ldx21, theta, phi, taup1, taup2, tauq1, phantom, work, *lwork, info);
}

void cunbdb5_(INT* m1, INT* m2, INT* n, c64* X1, INT* incx1, c64* X2, INT* incx2, c64* Q1, INT* ldq1, c64* Q2, INT* ldq2, c64* work, INT* lwork, INT* info) {
    cunbdb5(*m1, *m2, *n, X1, *incx1, X2, *incx2, Q1, *ldq1, Q2, *ldq2, work, *lwork, info);
}

void cunbdb6_(INT* m1, INT* m2, INT* n, c64* X1, INT* incx1, c64* X2, INT* incx2, c64* Q1, INT* ldq1, c64* Q2, INT* ldq2, c64* work, INT* lwork, INT* info) {
    cunbdb6(*m1, *m2, *n, X1, *incx1, X2, *incx2, Q1, *ldq1, Q2, *ldq2, work, *lwork, info);
}

void cuncsd_(char* jobu1, char* jobu2, char* jobv1t, char* jobv2t, char* trans, char* signs, INT* m, INT* p, INT* q, c64* X11, INT* ldx11, c64* X12, INT* ldx12, c64* X21, INT* ldx21, c64* X22, INT* ldx22, f32* theta, c64* U1, INT* ldu1, c64* U2, INT* ldu2, c64* V1T, INT* ldv1t, c64* V2T, INT* ldv2t, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* info) {
    cuncsd(jobu1, jobu2, jobv1t, jobv2t, trans, signs, *m, *p, *q, X11, *ldx11, X12, *ldx12, X21, *ldx21, X22, *ldx22, theta, U1, *ldu1, U2, *ldu2, V1T, *ldv1t, V2T, *ldv2t, work, *lwork, rwork, *lrwork, iwork, info);
}

void cuncsd2by1_(char* jobu1, char* jobu2, char* jobv1t, INT* m, INT* p, INT* q, c64* X11, INT* ldx11, c64* X21, INT* ldx21, f32* theta, c64* U1, INT* ldu1, c64* U2, INT* ldu2, c64* V1T, INT* ldv1t, c64* work, INT* lwork, f32* rwork, INT* lrwork, INT* iwork, INT* info) {
    cuncsd2by1(jobu1, jobu2, jobv1t, *m, *p, *q, X11, *ldx11, X21, *ldx21, theta, U1, *ldu1, U2, *ldu2, V1T, *ldv1t, work, *lwork, rwork, *lrwork, iwork, info);
}

void cung2l_(INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    cung2l(*m, *n, *k, A, *lda, tau, work, info);
}

void cung2r_(INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    cung2r(*m, *n, *k, A, *lda, tau, work, info);
}

void cungbr_(char* vect, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cungbr(vect, *m, *n, *k, A, *lda, tau, work, *lwork, info);
}

void cunghr_(INT* n, INT* ilo, INT* ihi, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    cunghr(*n, _ilo, _ihi, A, *lda, tau, work, *lwork, info);
}

void cungl2_(INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    cungl2(*m, *n, *k, A, *lda, tau, work, info);
}

void cunglq_(INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cunglq(*m, *n, *k, A, *lda, tau, work, *lwork, info);
}

void cungql_(INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cungql(*m, *n, *k, A, *lda, tau, work, *lwork, info);
}

void cungqr_(INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cungqr(*m, *n, *k, A, *lda, tau, work, *lwork, info);
}

void cungr2_(INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* work, INT* info) {
    cungr2(*m, *n, *k, A, *lda, tau, work, info);
}

void cungrq_(INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cungrq(*m, *n, *k, A, *lda, tau, work, *lwork, info);
}

void cungtr_(char* uplo, INT* n, c64* A, INT* lda, c64* tau, c64* work, INT* lwork, INT* info) {
    cungtr(uplo, *n, A, *lda, tau, work, *lwork, info);
}

void cungtsqr_(INT* m, INT* n, INT* mb, INT* nb, c64* A, INT* lda, c64* T, INT* ldt, c64* work, INT* lwork, INT* info) {
    cungtsqr(*m, *n, *mb, *nb, A, *lda, T, *ldt, work, *lwork, info);
}

void cungtsqr_row_(INT* m, INT* n, INT* mb, INT* nb, c64* A, INT* lda, c64* T, INT* ldt, c64* work, INT* lwork, INT* info) {
    cungtsqr_row(*m, *n, *mb, *nb, A, *lda, T, *ldt, work, *lwork, info);
}

void cunhr_col_(INT* m, INT* n, INT* nb, c64* A, INT* lda, c64* T, INT* ldt, c64* D, INT* info) {
    cunhr_col(*m, *n, *nb, A, *lda, T, *ldt, D, info);
}

void cunm22_(char* side, char* trans, INT* m, INT* n, INT* n1, INT* n2, c64* Q, INT* ldq, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cunm22(side, trans, *m, *n, *n1, *n2, Q, *ldq, C, *ldc, work, *lwork, info);
}

void cunm2l_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* info) {
    cunm2l(side, trans, *m, *n, *k, A, *lda, tau, C, *ldc, work, info);
}

void cunm2r_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* info) {
    cunm2r(side, trans, *m, *n, *k, A, *lda, tau, C, *ldc, work, info);
}

void cunmbr_(char* vect, char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cunmbr(vect, side, trans, *m, *n, *k, A, *lda, tau, C, *ldc, work, *lwork, info);
}

void cunmhr_(char* side, char* trans, INT* m, INT* n, INT* ilo, INT* ihi, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    INT _ilo = *ilo - 1;
    INT _ihi = *ihi - 1;
    cunmhr(side, trans, *m, *n, _ilo, _ihi, A, *lda, tau, C, *ldc, work, *lwork, info);
}

void cunml2_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* info) {
    cunml2(side, trans, *m, *n, *k, A, *lda, tau, C, *ldc, work, info);
}

void cunmlq_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cunmlq(side, trans, *m, *n, *k, A, *lda, tau, C, *ldc, work, *lwork, info);
}

void cunmql_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cunmql(side, trans, *m, *n, *k, A, *lda, tau, C, *ldc, work, *lwork, info);
}

void cunmqr_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cunmqr(side, trans, *m, *n, *k, A, *lda, tau, C, *ldc, work, *lwork, info);
}

void cunmr2_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* info) {
    cunmr2(side, trans, *m, *n, *k, A, *lda, tau, C, *ldc, work, info);
}

void cunmr3_(char* side, char* trans, INT* m, INT* n, INT* k, INT* l, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* info) {
    cunmr3(side, trans, *m, *n, *k, *l, A, *lda, tau, C, *ldc, work, info);
}

void cunmrq_(char* side, char* trans, INT* m, INT* n, INT* k, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cunmrq(side, trans, *m, *n, *k, A, *lda, tau, C, *ldc, work, *lwork, info);
}

void cunmrz_(char* side, char* trans, INT* m, INT* n, INT* k, INT* l, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cunmrz(side, trans, *m, *n, *k, *l, A, *lda, tau, C, *ldc, work, *lwork, info);
}

void cunmtr_(char* side, char* uplo, char* trans, INT* m, INT* n, c64* A, INT* lda, c64* tau, c64* C, INT* ldc, c64* work, INT* lwork, INT* info) {
    cunmtr(side, uplo, trans, *m, *n, A, *lda, tau, C, *ldc, work, *lwork, info);
}

void cupgtr_(char* uplo, INT* n, c64* AP, c64* tau, c64* Q, INT* ldq, c64* work, INT* info) {
    cupgtr(uplo, *n, AP, tau, Q, *ldq, work, info);
}

void cupmtr_(char* side, char* uplo, char* trans, INT* m, INT* n, c64* AP, c64* tau, c64* C, INT* ldc, c64* work, INT* info) {
    cupmtr(side, uplo, trans, *m, *n, AP, tau, C, *ldc, work, info);
}
