/**
 * @file dgetrf2.c
 * @brief Recursive LU factorization.
 */

#include <math.h>
#include <float.h>
#include <cblas.h>
#include "semicolon_lapack_double.h"

/**
 * Computes an LU factorization of a general M-by-N matrix A using partial
 * pivoting with row interchanges (recursive algorithm).
 *
 * The factorization has the form:
 *
 *     A = P * L * U
 *
 * where P is a permutation matrix, L is lower triangular with unit diagonal
 * elements, and U is upper triangular.
 *
 * This is a recursive version that achieves better cache utilization than the
 * iterative unblocked algorithm for medium-sized matrices.
 *
 * @param[in]     m     The number of rows of the matrix A (m >= 0).
 * @param[in]     n     The number of columns of the matrix A (n >= 0).
 * @param[in,out] A     On entry, the M-by-N matrix to be factored.
 *                      On exit, the factors L and U from the factorization;
 *                      the unit diagonal elements of L are not stored.
 * @param[in]     lda   The leading dimension of the array A (lda >= max(1,m)).
 * @param[out]    ipiv  The pivot indices; row i was interchanged with row
 *                      ipiv[i]. Array of dimension min(m,n), 0-based.
 *
 * @param[out]   info  Exit status.
 *                      - = 0: successful exit
 *                      - < 0: if info = -i, the i-th argument had an illegal value
 *                      - > 0: if info = i, U(i-1,i-1) is exactly zero. The factorization
 *                             has been completed, but U is exactly singular.
 *
 */
void dgetrf2(
    const int m,
    const int n,
    double * const restrict A,
    const int lda,
    int * const restrict ipiv,
    int *info)
{
    const double ONE = 1.0;
    const double ZERO = 0.0;
    const double NEG_ONE = -1.0;

    double sfmin, temp;
    int i, iinfo, n1, n2;
    int minmn = m < n ? m : n;

    // Test the input parameters
    *info = 0;
    if (m < 0) {
        *info = -1;
    } else if (n < 0) {
        *info = -2;
    } else if (lda < (m > 1 ? m : 1)) {
        *info = -4;
    }
    if (*info != 0) {
        xerbla("DGETRF2", -(*info));
        return;
    }

    // Quick return if possible
    if (m == 0 || n == 0) {
        return;
    }

    if (m == 1) {
        // Use unblocked code for one row case
        // Just need to handle IPIV and INFO
        ipiv[0] = 0;
        if (A[0] == ZERO) {
            *info = 1;
        }

    } else if (n == 1) {
        // Use unblocked code for one column case

        // Compute machine safe minimum
        sfmin = DBL_MIN;

        // Find pivot and test for singularity
        // cblas_idamax returns 0-based index
        i = cblas_idamax(m, A, 1);
        ipiv[0] = i;

        if (A[i] != ZERO) {
            // Apply the interchange
            if (i != 0) {
                temp = A[0];
                A[0] = A[i];
                A[i] = temp;
            }

            // Compute elements 2:M of the column
            if (fabs(A[0]) >= sfmin) {
                cblas_dscal(m - 1, ONE / A[0], &A[1], 1);
            } else {
                for (i = 0; i < m - 1; i++) {
                    A[1 + i] = A[1 + i] / A[0];
                }
            }

        } else {
            *info = 1;
        }

    } else {
        // Use recursive code
        n1 = minmn / 2;
        n2 = n - n1;

        //        [ A11 ]
        // Factor [ --- ]
        //        [ A21 ]

        dgetrf2(m, n1, A, lda, ipiv, &iinfo);

        if (*info == 0 && iinfo > 0) {
            *info = iinfo;
        }

        //                       [ A12 ]
        // Apply interchanges to [ --- ]
        //                       [ A22 ]

        // A(0, n1) = A + n1 * lda
        dlaswp(n2, A + n1 * lda, lda, 0, n1 - 1, ipiv, 1);

        // Solve A12
        // A(0, n1) = A + n1 * lda
        cblas_dtrsm(CblasColMajor, CblasLeft, CblasLower, CblasNoTrans, CblasUnit,
                    n1, n2, ONE, A, lda, A + n1 * lda, lda);

        // Update A22
        // A(n1, 0) = A + n1
        // A(0, n1) = A + n1 * lda
        // A(n1, n1) = A + n1 * lda + n1
        cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans,
                    m - n1, n2, n1, NEG_ONE, A + n1, lda,
                    A + n1 * lda, lda, ONE, A + n1 * lda + n1, lda);

        // Factor A22
        // A(n1, n1) = A + n1 * lda + n1
        dgetrf2(m - n1, n2, A + n1 * lda + n1, lda, &ipiv[n1], &iinfo);

        // Adjust INFO and the pivot indices
        if (*info == 0 && iinfo > 0) {
            *info = iinfo + n1;
        }
        for (i = n1; i < minmn; i++) {
            ipiv[i] = ipiv[i] + n1;
        }

        // Apply interchanges to A21
        dlaswp(n1, A, lda, n1, minmn - 1, ipiv, 1);
    }
}
