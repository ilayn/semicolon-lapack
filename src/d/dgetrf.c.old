/**
 * @file dgetrf.c
 * @brief Blocked LU factorization using Level 3 BLAS.
 */

#include <cblas.h>
#include "../include/lapack_tuning.h"
#include "semicolon_lapack_double.h"

/**
 * Computes an LU factorization of a general M-by-N matrix A using partial
 * pivoting with row interchanges.
 *
 * The factorization has the form:
 *
 *     A = P * L * U
 *
 * where P is a permutation matrix, L is lower triangular with unit diagonal
 * elements, and U is upper triangular.
 *
 * This is the right-looking Level 3 BLAS version of the algorithm.
 *
 * @param[in]     m     The number of rows of the matrix A (m >= 0).
 * @param[in]     n     The number of columns of the matrix A (n >= 0).
 * @param[in,out] A     On entry, the M-by-N matrix to be factored.
 *                      On exit, the factors L and U from the factorization;
 *                      the unit diagonal elements of L are not stored.
 * @param[in]     lda   The leading dimension of the array A (lda >= max(1,m)).
 * @param[out]    ipiv  The pivot indices; row i was interchanged with row
 *                      ipiv[i]. Array of dimension min(m,n), 0-based.
 *
 * @param[out]   info  Exit status.
 *                      - = 0: successful exit
 *                      - < 0: if info = -i, the i-th argument had an illegal value
 *                      - > 0: if info = i, U(i-1,i-1) is exactly zero. The factorization
 *                             has been completed, but U is exactly singular, and division
 *                             by zero will occur if it is used to solve a system of equations.
 *
 * @rst
 * .. note::
 *
 *    The algorithm uses blocking with block size determined from a static
 *    lookup table (see :c:func:`lapack_get_nb`), replacing LAPACK's
 *    ``ilaenv`` mechanism.
 *
 *    For small matrices or final panels, falls back to recursive
 *    :c:func:`dgetrf2`.
 * @endrst
 */
void dgetrf(
    const int m,
    const int n,
    double * const restrict A,
    const int lda,
    int * const restrict ipiv,
    int *info)
{
    const double ONE = 1.0;
    const double NEG_ONE = -1.0;

    int i, iinfo, j, jb, nb;
    int minmn = m < n ? m : n;

    // Test the input parameters
    *info = 0;
    if (m < 0) {
        *info = -1;
    } else if (n < 0) {
        *info = -2;
    } else if (lda < (m > 1 ? m : 1)) {
        *info = -4;
    }
    if (*info != 0) {
        xerbla("DGETRF", -(*info));
        return;
    }

    // Quick return if possible
    if (m == 0 || n == 0) {
        return;
    }

    // Block size from tuning table
    nb = lapack_get_nb("GETRF");

    if (nb <= 1 || nb >= minmn) {
        // Use unblocked code
        dgetrf2(m, n, A, lda, ipiv, info);
    } else {
        // Use blocked code
        for (j = 0; j < minmn; j += nb) {
            jb = minmn - j < nb ? minmn - j : nb;

            // Factor diagonal and subdiagonal blocks and test for exact
            // singularity.
            // A(j, j) = A + j + j * lda
            dgetrf2(m - j, jb, A + j + j * lda, lda, &ipiv[j], &iinfo);

            // Adjust INFO and the pivot indices
            if (*info == 0 && iinfo > 0) {
                *info = iinfo + j;
            }
            for (i = j; i < (m < j + jb ? m : j + jb); i++) {
                ipiv[i] = j + ipiv[i];
            }

            // Apply interchanges to columns 0:j-1
            if (j > 0) {
                dlaswp(j, A, lda, j, j + jb - 1, ipiv, 1);
            }

            if (j + jb < n) {
                // Apply interchanges to columns j+jb:n-1
                // A(0, j+jb) = A + (j + jb) * lda
                dlaswp(n - j - jb, A + (j + jb) * lda, lda, j, j + jb - 1, ipiv, 1);

                // Compute block row of U
                // A(j, j) = A + j + j * lda
                // A(j, j+jb) = A + j + (j + jb) * lda
                cblas_dtrsm(CblasColMajor, CblasLeft, CblasLower, CblasNoTrans, CblasUnit,
                            jb, n - j - jb, ONE, A + j + j * lda, lda,
                            A + j + (j + jb) * lda, lda);

                if (j + jb < m) {
                    // Update trailing submatrix
                    // A(j+jb, j) = A + (j + jb) + j * lda
                    // A(j, j+jb) = A + j + (j + jb) * lda
                    // A(j+jb, j+jb) = A + (j + jb) + (j + jb) * lda
                    cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans,
                                m - j - jb, n - j - jb, jb,
                                NEG_ONE, A + (j + jb) + j * lda, lda,
                                A + j + (j + jb) * lda, lda,
                                ONE, A + (j + jb) + (j + jb) * lda, lda);
                }
            }
        }
    }
}
